<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动量策略</title>
      <link href="/2023/03/21/%E5%8A%A8%E9%87%8F%E7%AD%96%E7%95%A5/"/>
      <url>/2023/03/21/%E5%8A%A8%E9%87%8F%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文内容基于<a href="https://uqer.datayes.com/">优矿平台</a>实现，为在校课程作业，仍有较多需要改进的地方。</p><h3 id="设置基本参数"><a href="#设置基本参数" class="headerlink" title="设置基本参数"></a>设置基本参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> datetime, math</span><br><span class="line"><span class="keyword">from</span> CAL.PyCAL <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> quartz_extensions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> dateutil.relativedelta <span class="keyword">import</span> relativedalta</span><br><span class="line"></span><br><span class="line">form_period = <span class="number">1</span></span><br><span class="line">hold_periond = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">start = <span class="string">&#x27;2013-01-01&#x27;</span></span><br><span class="line">end = <span class="string">&#x27;2021-12-31&#x27;</span></span><br><span class="line">benchmark = <span class="string">&#x27;HS300&#x27;</span></span><br><span class="line">universe_type = <span class="string">&#x27;HS300&#x27;</span></span><br><span class="line">universe = set_universe(universe_type)</span><br><span class="line">refresh_rate = Monthly(<span class="number">1</span>)</span><br><span class="line">freq = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">industry_type = <span class="string">&#x27;SW1&#x27;</span></span><br><span class="line"></span><br><span class="line">slippage = Slippage(value=<span class="number">0.001</span>, unit=<span class="string">&#x27;perValue&#x27;</span>)</span><br><span class="line">commission = Commission(buycost=<span class="number">0.001</span>, sellcost=<span class="number">0.002</span>, unit=<span class="string">&#x27;perValue&#x27;</span>)</span><br><span class="line">accounts = &#123;<span class="string">&#x27;stock_account&#x27;</span>:AccountConfig(account_type=<span class="string">&#x27;security&#x27;</span>,capital_base=<span class="number">10000000</span>,commission=commission,slippage=slippage)&#125;</span><br></pre></td></tr></table></figure><h3 id="去极值"><a href="#去极值" class="headerlink" title="去极值"></a>去极值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">winsorize_factor</span>(<span class="params">data,col,win_type=<span class="string">&#x27;NormDistDraw&#x27;</span>,n_draw=<span class="number">5</span></span>):</span><br><span class="line">    after_winsorize = winsorize(data[col].to_dict(),win_type=win_type,n_draw=n_draw)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> after_winsorize.items():</span><br><span class="line">        data.loc[key,col] = value</span><br></pre></td></tr></table></figure><h3 id="中性化"><a href="#中性化" class="headerlink" title="中性化"></a>中性化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">neutralize_factor</span>(<span class="params">data,col,target_date,industry_type=<span class="string">&#x27;SW1&#x27;</span>,exclude_style_list=[]</span>):</span><br><span class="line">    after_neutralize = neutralize(data[col].to_dict(),target_date=target_date,industry_type=industry_type,exclude_style_list=exclude_style_list)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> after_neutralize.items():</span><br><span class="line">        data.loc[key,col] = value</span><br></pre></td></tr></table></figure><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">standardize_factor</span>(<span class="params">data,col</span>):</span><br><span class="line">    after_standardize = standardize(data[col].to_dict())</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> after_standardize.items():</span><br><span class="line">        data.loc[key,col] = value</span><br></pre></td></tr></table></figure><h3 id="策略主体"><a href="#策略主体" class="headerlink" title="策略主体"></a>策略主体</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context</span>):</span><br><span class="line">    account = context.get_account(<span class="string">&#x27;stock_account&#x27;</span>)</span><br><span class="line">    universe = context.get_universe(asset_type=<span class="string">&#x27;stock&#x27;</span>,exclude_halt=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    beginDate = context.current_date + relativedelta(months=-from_period)</span><br><span class="line">    endDate = context.current_date</span><br><span class="line">    data = DataAPI.MktEqudGet(secID=universe,beginDate=beginDate,endDate=endDate,pandas=<span class="string">&quot;1&quot;</span>,field=[<span class="string">&#x27;secID&#x27;</span>,<span class="string">&#x27;tradeDate&#x27;</span>,<span class="string">&#x27;closePrice&#x27;</span>]).set_index(<span class="string">&#x27;secID&#x27;</span>).dropna()</span><br><span class="line">    </span><br><span class="line">    factors = &#123;<span class="string">&#x27;symbol&#x27;</span>:[],<span class="string">&#x27;return&#x27;</span>:[]&#125;</span><br><span class="line">    symbols = <span class="built_in">list</span>(<span class="built_in">set</span>(data._stat_axis.value.tolist()))</span><br><span class="line">    <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">        factors[<span class="string">&#x27;symbol&#x27;</span>].append(symbol)</span><br><span class="line">        factors[<span class="string">&#x27;return&#x27;</span>].append(data.loc[symbol].iloc[-<span class="number">1</span>][<span class="string">&#x27;closePrice&#x27;</span>]/data.loc[symbol].iloc[<span class="number">0</span>][<span class="string">&#x27;closePrice&#x27;</span>])</span><br><span class="line">    factors = pd.DataFrame(factors).set_index(<span class="string">&#x27;symbol&#x27;</span>) </span><br><span class="line">    </span><br><span class="line">    winsorize_factor(factors,<span class="string">&#x27;return&#x27;</span>,win_type=<span class="string">&#x27;NormDistDraw&#x27;</span>,n_draw=<span class="number">5</span>)</span><br><span class="line">    neutralize_factor(factors,<span class="string">&#x27;return&#x27;</span>,target_date=context.current_date,industry_type=industry_type)</span><br><span class="line">    standardize_factor(factors,<span class="string">&#x27;return&#x27;</span>)</span><br><span class="line">    weights = long_only(factors[<span class="string">&#x27;return&#x27;</span>].to_dict(),target_date=context.current_date,industry_type=industry_type,universe_type=universe_type,select_type=<span class="number">1</span>,weight_type=<span class="number">1</span>,top_ratio=<span class="number">0.2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> symbol <span class="keyword">in</span> account.get_positions():</span><br><span class="line">        <span class="keyword">if</span> symbol <span class="keyword">not</span> <span class="keyword">in</span> weights.keys():</span><br><span class="line">            account.order_to(symbol,<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> symbol,weight <span class="keyword">in</span> weights.items():</span><br><span class="line">        <span class="keyword">if</span> context.current_price &gt; <span class="number">0</span>:</span><br><span class="line">            value = weight*account.portfolio_value</span><br><span class="line">            share = <span class="built_in">int</span>(value/context.current_price(symbol)/<span class="number">100</span>)*<span class="number">100</span></span><br><span class="line">            account.order_to(symbol,share)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 量化投资相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Momentum strategy </tag>
            
            <tag> Quantitative investment </tag>
            
            <tag> Datayes! </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习7：线性回归+基础优化算法</title>
      <link href="/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A07%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92+%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A07%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92+%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习6：自动求导</title>
      <link href="/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A06%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/"/>
      <url>/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A06%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="向量链式法则"><a href="#向量链式法则" class="headerlink" title="向量链式法则"></a>向量链式法则</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211322600.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211324862.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211325228.png" alt=""></p><h3 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211328680.png" style="zoom: 67%;" /></p><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211329261.png" style="zoom: 67%;" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet impot sym</span><br><span class="line"></span><br><span class="line">a = sym.var()</span><br><span class="line">b = sym.var()</span><br><span class="line">c = <span class="number">2</span>*a+b</span><br><span class="line"><span class="comment"># bind data into a and b later</span></span><br></pre></td></tr></table></figure><p>显式构造：Tensorflow/Theano/MXNet</p><p>隐式构造：PyTorch/MXNet</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    a = nd.ones((<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">    b = nd.ones((<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">    c = <span class="number">2</span>*a+b</span><br></pre></td></tr></table></figure><h3 id="自动求导的两种模式"><a href="#自动求导的两种模式" class="headerlink" title="自动求导的两种模式"></a>自动求导的两种模式</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211335555.png" style="zoom: 67%;" /></p><h3 id="反向累积复杂度"><a href="#反向累积复杂度" class="headerlink" title="反向累积复杂度"></a>反向累积复杂度</h3><p>计算复杂度：O(n)，n是操作子个数。通常正向和反向的代价类似。</p><p>内存复杂度：O(n)，因为需要存储正向的所有中间结果。</p><p>和正向累积对比：O(n)计算复杂度用来计算一个变量的梯度；O(1)内存复杂度。</p><h3 id="自动求导实现"><a href="#自动求导实现" class="headerlink" title="自动求导实现"></a>自动求导实现</h3><p>假设相对函数$y=2x^T x$，关于列向量x求导</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.arange(<span class="number">4.0</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>在计算y关于x的梯度之前，需要一个地方来存储梯度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">x.grad  <span class="comment">#默认值是None</span></span><br></pre></td></tr></table></figure><p>接下来计算y</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = <span class="number">2</span>*torch.dot(x, x)</span><br><span class="line">y</span><br></pre></td></tr></table></figure><p>通过调用反向传播函数来自动计算y关于x每个分量的梯度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad == <span class="number">4</span>*x</span><br></pre></td></tr></table></figure><p>接下来计算x的另一个函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()  <span class="comment"># 默认情况下，PyTorch会累积梯度，所以需要清除之前的值</span></span><br><span class="line">y = x.<span class="built_in">sum</span>()</span><br><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure><p>深度学习中，我们的目的不是计算微分矩阵，而是批量中每个样本单独计算的偏导数之和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y = x * x</span><br><span class="line">y.<span class="built_in">sum</span>().backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure><p>将某些计算移动到记录的计算图之外</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y = x * x</span><br><span class="line">u = y.detach()</span><br><span class="line">z = u * x</span><br><span class="line"></span><br><span class="line">z.<span class="built_in">sum</span>().backward()</span><br><span class="line">x.grad == u</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.<span class="built_in">sum</span>().backward()</span><br><span class="line">x.grad == <span class="number">2</span>*x</span><br></pre></td></tr></table></figure><p>即使构建函数的计算图需要通过Python控制流（例如，条件、循环或任意函数调用），我们仍然可以计算得到的变量的梯度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    b = a * <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> b.norm() &lt; <span class="number">1000</span>:</span><br><span class="line">        b = b * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> b.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">        c = b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = <span class="number">100</span> * b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">a = torch.randn(size=(),requires_grad=<span class="literal">True</span>)</span><br><span class="line">d = f(a)</span><br><span class="line">d.backward()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习5：矩阵计算</title>
      <link href="/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A05%EF%BC%9A%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/"/>
      <url>/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A05%EF%BC%9A%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="标量导数"><a href="#标量导数" class="headerlink" title="标量导数"></a>标量导数</h3><p><img src="C:/Users/yumiaomiao/Desktop/12.png" alt=""></p><h3 id="亚导数"><a href="#亚导数" class="headerlink" title="亚导数"></a>亚导数</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211310820.png" alt=""></p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>x是向量，y是标量时：</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211313343.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211315562.png" alt=""></p><p>y是列向量，x是标量时：</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211316941.png" alt=""></p><p>x、y均为向量时：</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211317139.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211318888.png" alt=""></p><h3 id="拓展到矩阵"><a href="#拓展到矩阵" class="headerlink" title="拓展到矩阵"></a>拓展到矩阵</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211320884.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习4：线性代数</title>
      <link href="/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A04%EF%BC%9A%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A04%EF%BC%9A%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210949230.png" alt=""></p><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210950495.png" style="zoom:50%;" /></p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210950623.png" style="zoom:50%;" /></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210952829.png" style="zoom:50%;" /></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210953225.png" style="zoom:50%;" /></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210953672.png" style="zoom:50%;" /></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210956144.png" style="zoom:50%;" /></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210959556.png" style="zoom:50%;" /></p><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211001890.png" style="zoom:50%;" /></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210958444.png" style="zoom:50%;" /></p><h3 id="线性代数实现"><a href="#线性代数实现" class="headerlink" title="线性代数实现"></a>线性代数实现</h3><p>标量由只有一个元素的张量表示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">3.0</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2.0</span>])</span><br><span class="line"></span><br><span class="line">x+y, x*y, x/y, x**y</span><br></pre></td></tr></table></figure><p>可以将向量视为标量值组成的列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arrange(<span class="number">4</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>通过张量的索引来访问任一元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>访问张量的长度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(x)</span><br></pre></td></tr></table></figure><p>只有一个轴的张量，形状只有一个元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure><p>通过指定两个分量m和n来创建一个形状为m*n的矩阵</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>).reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>矩阵的转置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure><p>对称矩阵等于其转置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">B</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B == B.T</span><br></pre></td></tr></table></figure><p>就像向量是标量的推广，矩阵是向量的推广一样，我们可以构建具有更多轴的数据结构</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 2维3行4列</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><p>给定具有相同形状的任何两个张量，任何按元素二元运算的结果都将是相同形状的张量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">B = A.clone()  <span class="comment">#通过分配新内存，将A的一个副本分配给B</span></span><br><span class="line">A, A+B</span><br></pre></td></tr></table></figure><p>两个矩阵的按元素乘法成为<strong>哈达玛积Hadamard product</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A * B</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a + X, (a * X).shape</span><br></pre></td></tr></table></figure><p>计算其元素的和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>, dtype=torch.float32)</span><br><span class="line">x, x.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>表示任意形状张量的元素和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.shape, A.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>指定求和汇总张量的轴</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A_sum_axis0 = A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">A_sum_axis0, A_sum_axis0.shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A_sum_axis1 = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>)  <span class="comment">#axis=0代表跨行，axis=1代表跨列</span></span><br><span class="line">A_sum_axis1, A_sum_axis1.shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>])  <span class="comment">#same as &#x27;A.sum()&#x27;</span></span><br></pre></td></tr></table></figure><p>一个与求和相关的量是平均值mean/average</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.mean(), A.<span class="built_in">sum</span>() / A.numel</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.mean(axis=<span class="number">0</span>), A.<span class="built_in">sum</span>(axis=<span class="number">0</span>) / A.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>计算总和或均值时保持轴数不变</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)  <span class="comment">#keepdims默认为False</span></span><br><span class="line">sum_A</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211304425.png" alt=""></p><p>通过广播将A除以sum_A</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A / sum_A  <span class="comment">#广播机制需要保证A的维度和sum_A的维度一样</span></span><br></pre></td></tr></table></figure><p>某个轴计算A元素的累积总和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.cumsum(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>点积是相同位置的按元素乘积的和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.ones(<span class="number">4</span>, dtype=torch.<span class="built_in">float</span>(<span class="number">32</span>))</span><br><span class="line">x, y, torch.dot(x,y)  <span class="comment">#dot表示点积</span></span><br></pre></td></tr></table></figure><p>通过执行按元素乘法，然后进行求和来表示两个向量的点积</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.<span class="built_in">sum</span>(x * y)</span><br></pre></td></tr></table></figure><p>矩阵向量积Ax是一个长度为m的列向量，其中$i^{th}\$元素是点积$a^T_ {i}$ x</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.shape, x.shape, torch.mv(A, x)</span><br></pre></td></tr></table></figure><p>将矩阵-矩阵乘法AB看作是简单地执行m次矩阵-向量积，并将结果拼接在一起，形成一个n*m矩阵</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = torch.ones(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">torch.mm(A, B)</span><br></pre></td></tr></table></figure><p>$L_2$范数是向量元素平方和的平方根：$||x||_2$=$\sqrt{\sum_1^n x_i^{2}}$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = torch.tensor([<span class="number">3.0</span>, -<span class="number">4.0</span>])</span><br><span class="line">torch.norm(u)</span><br></pre></td></tr></table></figure><p>$L_1$范数是向量元素平方和的平方根：$||x||_1$=$\sum_1^n |x_i|$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.<span class="built_in">abs</span>(u).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>矩阵的<strong>佛罗贝尼乌斯范数Frobenius norm</strong>是矩阵元素的平方和的平方根：$||X||<em>F$=$\sqrt{\sum_1^m \sum_1^n x^2</em>{ij}}$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.norm(torch.ones((<span class="number">4</span>, <span class="number">9</span>)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习3：数据预处理</title>
      <link href="/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A03%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2023/03/21/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A03%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>创建一个人工数据集，并存储在csv文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;data&#x27;</span>).exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file,<span class="string">&#x27;w&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment">#列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment">#每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>从创建的csv文件中加载原始数据集</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有安装pandas，只需取消对以下行的注释：</span></span><br><span class="line"><span class="comment"># !pip install pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_file)  <span class="comment">#pandas提供read_csv</span></span><br><span class="line">data</span><br></pre></td></tr></table></figure><p>处理缺失的数据，典型的方法包括插值和删除，下面为插值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs,outputs = data.iloc[:,<span class="number">0</span>:<span class="number">2</span>],data.iloc[:,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># index location，通过行号来取行数据（如取第二行的数据）</span></span><br><span class="line">inputs = inputs.fillna(inputs.mean())  <span class="comment">#把所有NA值填成mean值</span></span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><p>对于inputs中的类别值或离散值，将“NaN”视为一个类别</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>)  <span class="comment">#dummy</span></span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303210935865.png" alt=""></p><p>现在inputs和outputs中所有条目都是数值类型，它们可以转换成张量格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x,y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line">x,y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量化择时——支持向量机模型（三）：改进</title>
      <link href="/2023/03/20/%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89%E6%94%B9%E8%BF%9B/"/>
      <url>/2023/03/20/%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文内容基于<a href="https://uqer.datayes.com/">优矿平台</a>实现，为在校课程作业，仍有较多需要改进的地方。</p><h3 id="改进内容"><a href="#改进内容" class="headerlink" title="改进内容"></a>改进内容</h3><ul><li><p>大盘涨跌判断</p><p>原把30天后的涨跌算作大盘指数涨跌，容易让模型拟合噪音。本文对其进行阈值的设定，高于10%的阈值才认为大盘在涨，低于10%才认为大盘在跌。</p></li><li><p>参数寻优</p><p>原在寻找最优C值的过程中，设定i的范围在300-400之间，C=i，即C的选取范围也在300-400之间；在寻找最优gamma值的过程中，设定i的范围在100-200之间，gamma=i/100，即gamma的选取范围在1-2之间。</p><p>范围过小，本文设定i的范围在1-1000之间。C值寻优过程中，C=i/10，即C的范围在0-100之间；gamma值寻优过程中，gamma=i，即C的范围在0-1000之间。</p></li></ul><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>获取2013.3.1-2018.3.31相关指标数据，判断30天后的涨跌。</p><p>设定30天后的涨幅大于10%认为大盘在涨，跌幅大于10%认为大盘在跌。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_arr</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        se = talib.MIN(np.array(arr),<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        se = np.array([np.nan]*<span class="built_in">len</span>(arr))</span><br><span class="line">    <span class="keyword">return</span> se</span><br><span class="line">fields = [<span class="string">&#x27;tradeDate&#x27;</span>,<span class="string">&#x27;closeIndex&#x27;</span>,<span class="string">&#x27;highestIndex&#x27;</span>,<span class="string">&#x27;lowestIndex&#x27;</span>,<span class="string">&#x27;turnoverVol&#x27;</span>,<span class="string">&#x27;CHG&#x27;</span>,<span class="string">&#x27;CHGPct&#x27;</span>]</span><br><span class="line">stock = <span class="string">&#x27;00300&#x27;</span></span><br><span class="line"></span><br><span class="line">index_raw = DataAPI.MktIdxdGet(ticker=stock,beginDate=<span class="string">u&#x27;2013-03-01&#x27;</span>,endDate=<span class="string">u&#x27;2018-03-31&#x27;</span>,field=fields,panndas=<span class="string">&quot;1&quot;</span>)</span><br><span class="line">index_date = index_raw.set_index(<span class="string">&#x27;tradeDate&#x27;</span>)</span><br><span class="line">index_date = index_rate.dropna()</span><br><span class="line">index_date[<span class="string">&#x27;max_difference&#x27;</span>] = index_date[<span class="string">&#x27;highestIndex&#x27;</span>] - index_date[<span class="string">&#x27;lowestIndex&#x27;</span>]</span><br><span class="line">index_date[<span class="string">&#x27;max_of_30day&#x27;</span>] = index_date.apply(max_arr)[<span class="string">&#x27;highestIndex&#x27;</span>]</span><br><span class="line">index_date[<span class="string">&#x27;min_of_30day&#x27;</span>] = index_date.apply(min_arr)[<span class="string">&#x27;lowestIndex&#x27;</span>]</span><br><span class="line">index_date[<span class="string">&#x27;max_difference_of_30day&#x27;</span>] = index_date.apply(max_arr)[<span class="string">&#x27;max_difference&#x27;</span>]</span><br><span class="line">index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>] = np.nan</span><br><span class="line">index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>][<span class="number">0</span>:-<span class="number">30</span>] = np.array(index_date[<span class="string">&#x27;closeIndex&#x27;</span>][<span class="number">30</span>:])</span><br><span class="line">index_date = index_date.dropna()</span><br><span class="line">index_date[(index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>]&lt;index_date[<span class="string">&#x27;closeIndex&#x27;</span>]*<span class="number">1.1</span>)&amp;(index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>]&gt;index_date[<span class="string">&#x27;closeIndex&#x27;</span>]*<span class="number">0.9</span>)] = np.nan</span><br><span class="line">index_date = index_date.dropna()</span><br><span class="line">index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>][index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>]&gt;index_date[<span class="string">&#x27;closeIndex&#x27;</span>]*<span class="number">1.1</span>] = <span class="string">&quot;up&quot;</span></span><br><span class="line">index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>][index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>]&lt;index_date[<span class="string">&#x27;closeIndex&#x27;</span>]*<span class="number">0.9</span>] = <span class="string">&quot;down&quot;</span></span><br><span class="line">index_date = index_date.dropna()</span><br><span class="line">lables = index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>]</span><br><span class="line">featruns = index_date.drop([<span class="string">&#x27;closeIndex_after30days&#x27;</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> corss_validation</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line">scaler = preprocessing.StandardScaler().fit(features)</span><br><span class="line">features_scaler = scaler.transform(features)</span><br><span class="line">X_train,X_test,y_train,y_test = cross_validation.train_test_split(features_scaler,lables,test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="获取准确率"><a href="#获取准确率" class="headerlink" title="获取准确率"></a>获取准确率</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf_svm = svm.SVC()</span><br><span class="line">clf_svm.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span><span class="string">&quot;样本内预测准确率为：%0.2f&quot;</span>%(clf_svm.score(X_test,y_test))</span><br></pre></td></tr></table></figure><h3 id="参数寻优"><a href="#参数寻优" class="headerlink" title="参数寻优"></a>参数寻优</h3><p>首先，调C值，设定i值范围在1-1000，C=i/10，即C值的范围在0-100之间，寻找C值的最优区间。结果为0-20之间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i_list = []</span><br><span class="line">score_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">1000</span>,<span class="number">1</span>):</span><br><span class="line">    i = i/<span class="number">10.</span></span><br><span class="line">    clf_svm = svm.SVC(C = i)</span><br><span class="line">    clf_svm.fit(X_train,y_train)</span><br><span class="line">    i_list.append(i)</span><br><span class="line">    score_list.append(clf_svm.score(X_test,y_test))</span><br><span class="line">    </span><br><span class="line">score_list_df = pd.DataFrame(&#123;<span class="string">&#x27;C_score&#x27;</span>:i_list,<span class="string">&#x27;in_sets&#x27;</span>:score_list&#125;)</span><br><span class="line">score_list_df.plot(x=<span class="string">&#x27;C_score&#x27;</span>,title=<span class="string">&#x27;accuracy change with C&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303202219009.png" alt=""></p><p>接下来，调gamma值，设定i值范围在1-1000，gamma=i，即gamma值的范围在0-1000之间，寻找gamma值的最优区间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i_list = []</span><br><span class="line">score_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>,<span class="number">1</span>):</span><br><span class="line">    i = i/<span class="number">1</span></span><br><span class="line">    clf_svm = svm.SVC(C=<span class="number">1</span>,gamma=<span class="number">1</span>)</span><br><span class="line">    clf_svm.fit(X_train,y_train)</span><br><span class="line">    i_list.append(i)</span><br><span class="line">    score_list.append(clf_svm.score(X_test,y_test))</span><br><span class="line">    </span><br><span class="line">score_list_df = pd.DataFrame(&#123;<span class="string">&#x27;gamma_score&#x27;</span>:i_list,<span class="string">&#x27;in_sets&#x27;</span>:score_list&#125;)</span><br><span class="line">score_list_df.plot(x=<span class="string">&#x27;gamma_score&#x27;</span>,title=<span class="string">&#x27;accuracy change with gamma&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后，使用grisearchCV在参数相应范围内寻找最优解。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> ShuffleSplit</span><br><span class="line">i = <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">params = &#123;<span class="string">&#x27;C&#x27;</span>:<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>),<span class="string">&#x27;gamma&#x27;</span>:[x/<span class="number">100.</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>),<span class="string">&#x27;kernel&#x27;</span>:[<span class="string">&#x27;linear&#x27;</span>,<span class="string">&#x27;rbf&#x27;</span>,<span class="string">&#x27;sigmoid&#x27;</span>]]&#125;</span><br><span class="line"></span><br><span class="line">clf_svm = svm.SVC()</span><br><span class="line"></span><br><span class="line">grid = GridSearchCV(clf_svm,params)</span><br><span class="line">grid = grid.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span> grid.best_estimator</span><br></pre></td></tr></table></figure><p>结果为：C=1，gamma=0.01，kernel=linear。</p><h3 id="计算准确率"><a href="#计算准确率" class="headerlink" title="计算准确率"></a>计算准确率</h3><p>在最优解的基础上再次计算准确率，结果为0.92，高于参数寻优前的预测准确率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf_svm = svm.SVC(C=<span class="number">1</span>,gamma=<span class="number">0.01</span>,kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf_svm.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span><span class="string">&quot;样本内预测准确率为：%0.2f&quot;</span> %(clf_svm.score(X_test,y_test))</span><br></pre></td></tr></table></figure><h3 id="模型回测"><a href="#模型回测" class="headerlink" title="模型回测"></a>模型回测</h3><p>运用SVM预测模型预测沪深300指数的走势，操作方法是每日收盘后判断沪深300指数未来30天的收盘价是否大于近日的收盘价的10%。</p><p>如果预测出上涨，在当下一日的价格低于前一日收盘价时，买入满足条件的股票，总价值占虚拟账户的10%；如果预测出下跌或没有变化，当下一日的价格涨幅到买入价的1.2倍时，清仓卖出，每日只进行一次交易或不进行交易，整个过程由交易系统自动进行。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303202230791.png" alt=""></p><h3 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h3><h4 id="数据选取"><a href="#数据选取" class="headerlink" title="数据选取"></a>数据选取</h4><p>选取2015.1.1-2021.6.1的沪深 300 指数，其中2015.1.1-2020.6.1的数据用来训练模型各参数，2020.6.1-2021.4.1的数据作为测试集，即用来回测模型的效果。</p><p>同时，为了去除数据的量纲不同带来的影响，对数据进行Z-score标准化。</p><h4 id="特征指标说明"><a href="#特征指标说明" class="headerlink" title="特征指标说明"></a>特征指标说明</h4><p>在预测问题中， 特征指标表示为一个维数为 n 的向量，比较成熟、被证明有效的特征指标如下（与前文一致）：</p><p>X1——收盘指数 </p><p>X2——当日最大指数 </p><p>X3——当日最小指数 </p><p>X4——涨跌幅 </p><p>X5——成交量 </p><p>X6——前 30 日平均涨跌幅 </p><p>X7——前 30 日最大日波动</p><h4 id="参数寻优-1"><a href="#参数寻优-1" class="headerlink" title="参数寻优"></a>参数寻优</h4><p>在未调参之前，样本内预测准确率为：0.93。</p><p>通过优矿对 C 值、g 值进行调参，调参结果如图所示：</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303202233784.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303202234957.png" alt=""></p><p>采用基于交叉验证的网格搜索法在参数C和g的最佳取值范围内寻找最优解，通过优矿计算出参数C的最优值为5，g的最优值为0.08。</p><p>在最优解的基础上再次计算一次准确率，参数最优化之后的模型准确率提高到0.98。</p><h4 id="回测"><a href="#回测" class="headerlink" title="回测"></a>回测</h4><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303202236547.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 量化投资相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quantitative investment </tag>
            
            <tag> Datayes! </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习1：环境配置</title>
      <link href="/2023/03/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88Pytorch%EF%BC%891%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/03/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88Pytorch%EF%BC%891%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>人工智能：一套用来学习规则/映射关系的固定算法/方法。</p><p>深度学习：机器学习的分支，是一种以人工神经网络为架构，对资料进行表征学习的算法。</p><h3 id="深度学习细分领域"><a href="#深度学习细分领域" class="headerlink" title="深度学习细分领域"></a>深度学习细分领域</h3><ul><li>计算机视觉CV</li><li>自然语言处理NLP</li><li>自动语音识别ASR</li><li>人工智能与物联网AIoT</li><li>时间序列分析&amp;异常检测AIOps</li><li>机器人控制</li><li>推荐系统</li><li>AI for Science</li><li>强化学习RL</li><li>AI+</li></ul><h3 id="解决欠拟合（减少偏差）的方法"><a href="#解决欠拟合（减少偏差）的方法" class="headerlink" title="解决欠拟合（减少偏差）的方法"></a>解决欠拟合（减少偏差）的方法</h3><ul><li><p>增加模型复杂度，例如增加层数、每层有更多的filters。</p></li><li><p>减少正则化，例如dropout或L1、L2正则化。</p></li><li><p>错误分析，即了解出问题的根因。</p></li><li><p>选择不同的（最先进的）模型结构，例如从VGG16转为Resnet。</p></li><li><p>调整超参数，例如学习率。</p></li></ul><h3 id="解决过拟合（减少方差）的方法"><a href="#解决过拟合（减少方差）的方法" class="headerlink" title="解决过拟合（减少方差）的方法"></a>解决过拟合（减少方差）的方法</h3><ul><li><p>添加更多的训练数据</p></li><li><p>添加规范化，如Batch Norm、Layer Norm</p></li><li><p>使用数据增强</p></li><li><p>使用正则化，如dropout、L2正则</p></li><li><p>错误分析</p></li><li><p>选择不同的（最先进的）模型架构</p></li><li><p>调整超参数，如学习率</p></li><li><p>Early stop</p></li><li><p>删除部分特征</p></li><li><p>减少模型规模</p></li></ul><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>教程参考：<a href="https://learning.datawhale.club/live_pc/l_6406e1a9e4b07b05583a25f1">Datawhale环境配置演示</a></p><p>个人：</p><ul><li>进入，conda activate d2l</li><li>打开，jupyter notebook</li><li>停止，ctrl+c</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习2：数据操作</title>
      <link href="/2023/03/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88Pytorch%EF%BC%892%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/03/20/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88Pytorch%EF%BC%892%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="N维数组"><a href="#N维数组" class="headerlink" title="N维数组"></a>N维数组</h3><p>机器学习和神经网络的主要数据结构。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303201417660.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303201418953.png" alt=""></p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>形状：例如3*4矩阵。</p><p>每个元素的数据类型：例如32位浮点数。</p><p>每个元素的值：例如全是0，或者随机数。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>行数和列数均从0开始。</p><p>访问一个元素：[1,2]</p><p>访问一行：[1,:]</p><p>访问一列：[:,1]</p><p>访问子区域：左开右闭；隔3行一跳</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303201424606.png" alt=""></p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><h4 id="张量tensor"><a href="#张量tensor" class="headerlink" title="张量tensor"></a>张量tensor</h4><p>表示一个数值组成的数组，这个数组可能有多个维度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>通过张量的shape属性访问张量的形状和张量中元素的总数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.shape</span><br><span class="line">x.numel()  <span class="comment">#number elements</span></span><br></pre></td></tr></table></figure><p>调用reshape函数，改变一个张量的形状而不改变元素数量和元素值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x.reshape(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">#3行4列</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>使用全0、全1、其他常量或者从特定分布中随机采样的数字</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">torch.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>通过提供包含数值的Python列表（或嵌套列表）来为所需张量中的每个元素赋予确定值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>常见的标准算术运算符（+、-、<em>、/和*</em>）都可以被升级为按元素运算</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">x+y,x-y,x*y,x/y,x**y  <span class="comment">#**是求幂</span></span><br></pre></td></tr></table></figure><p>指数运算等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.exp(x)</span><br></pre></td></tr></table></figure><p>把多个张量连结在一起</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>,dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">torch.cat((X,Y),dim=<span class="number">0</span>),torch.cat((X,Y),dim=<span class="number">1</span>)  <span class="comment">#dim=0在行上面把X和Y合并起来，dim=1在列上面合并</span></span><br></pre></td></tr></table></figure><p>通过逻辑运算符构建二元张量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X == Y  <span class="comment">#False/True</span></span><br></pre></td></tr></table></figure><p>对张量中所有元素进行求和会产生一个只有一个元素的张量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>即使形状不同，仍然可以调用<strong>广播机制broadcasting mechanism</strong>来执行按元素操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">a + b  <span class="comment">#扩展数组,a复制为3*2，b复制为3*2，再相加</span></span><br></pre></td></tr></table></figure><p>用[-1]选择最后一个元素，用[1:3]选择第二个和第三个元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X[-<span class="number">1</span>], X[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>除读取外，可以通过索引将元素写入矩阵</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X[<span class="number">1</span>,<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><p>为多个元素赋相同的值，只需要索引所有元素，然后为它们赋值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X[<span class="number">0</span>:<span class="number">2</span>,:] = <span class="number">12</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Study notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多因子策略</title>
      <link href="/2023/03/20/%E5%A4%9A%E5%9B%A0%E5%AD%90%E7%AD%96%E7%95%A5/"/>
      <url>/2023/03/20/%E5%A4%9A%E5%9B%A0%E5%AD%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文内容基于<a href="https://www.joinquant.com/">聚宽平台</a>实现，为在校课程作业，仍有较多需要改进的地方。</p><h3 id="研究目的"><a href="#研究目的" class="headerlink" title="研究目的"></a>研究目的</h3><p>本文对因子组合进行确定，用较少的共同因子来代替股票的各种特征。</p><p>为了降低构建因子组合的难度，本文从基准的特征出发确定因子。从股票组合管理的角度来看，因子最大的作用在于风险描述继而对冲，从而获得Alpha收益，所以基准明显的特征应该是风险。</p><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><ul><li><p>从基准的角度获取较为通用的因子</p><p>本文的基础基准设定为上证50、沪深300和中证500，考虑到这三个基准的编制方式以及个股的通用性质，对以下七个因子进行研究：市值、股本、ROE、净利润增长率、PE、换手率以及EPS。</p></li><li><p>根据因子在指数成分股中的暴露分析</p><p>从基准的角度看，因子是否通用，是否能代表基准明显的特征。</p></li><li><p>分析因子之间的相关性</p><p>避免相关性过高的因子进入因子组合，相关性过高的因子对于线性模型而言，往往导致模型出现较大误差，使得模型的预测能力下降。</p></li><li><p>研究因子IC</p><p>分析因子解释力度是否较强，判断因子对个股未来收益的预测能力。</p></li><li><p>构建多因子组合并进行模型检验。</p></li></ul><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><h4 id="日期列表获取"><a href="#日期列表获取" class="headerlink" title="日期列表获取"></a>日期列表获取</h4><p>由于研究环境内存限制，全市场日频数据量较多，无法在聚宽平台进行处理，因此本文考虑以周为频率对不同风格因子进行分析。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_period_date</span>(<span class="params">period, start_date, end_date</span>):</span><br><span class="line">    stock_data = get_price(<span class="string">&#x27;000001.XSHE&#x27;</span>, start_date, end_date, <span class="string">&#x27;daily&#x27;</span>, fields=[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">    stock_data[<span class="string">&#x27;date&#x27;</span>] = stock_data.index</span><br><span class="line">    period_stock_data = stock_data.resample(period, how=<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">    date = period_stock_data.index</span><br><span class="line">    pydate_array = date.to_pydatetime()</span><br><span class="line">    date_only_array = np.vectorize(<span class="keyword">lambda</span> s: s.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>))(pydate_array)</span><br><span class="line">    date_only_series = pd.Series(date_only_array)</span><br><span class="line">    start date = datetime.datetime.strptime(start_date, <span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    start_date = start_date-datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">    start_date = start_date.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    date_list = date_only_series.values.tolist()</span><br><span class="line">    date_list.insert(<span class="number">0</span>,start_date)</span><br><span class="line">    TradeDate = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> date_list:</span><br><span class="line">        temp = <span class="built_in">list</span>(get_trade_days(end_date=i, count==<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">        TradeDate.append(<span class="built_in">str</span>(temp))</span><br><span class="line">    <span class="keyword">return</span> TradeDate</span><br><span class="line">np.array(get_period_date(<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;2013-01-01&#x27;</span>,<span class="string">&#x27;2018-01-01&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="数据获取-1"><a href="#数据获取-1" class="headerlink" title="数据获取"></a>数据获取</h4><p>通过对基准编制规则进行解读，从直观上对基准的特征有所了解，然后形成逻辑且具有经济意义的初步因子组合列表。</p><div class="table-container"><table><thead><tr><th style="text-align:center">指数名称</th><th style="text-align:center">股票池</th><th style="text-align:center">股票个数</th><th style="text-align:center">加权方法</th><th style="text-align:center">选股条件</th><th style="text-align:center">对应因子</th></tr></thead><tbody><tr><td style="text-align:center">上证50</td><td style="text-align:center">上证180</td><td style="text-align:center">20</td><td style="text-align:center">派许加权+调整股本</td><td style="text-align:center">规模、流动性</td><td style="text-align:center">流通市值、成交金额</td></tr><tr><td style="text-align:center">沪深300</td><td style="text-align:center">全A股市值最大的300只</td><td style="text-align:center">300</td><td style="text-align:center">派许加权+调整股本</td><td style="text-align:center">规模</td><td style="text-align:center">日均总市值</td></tr><tr><td style="text-align:center">中证500</td><td style="text-align:center">全A股扣除市值最大的300只后的前500只</td><td style="text-align:center">500</td><td style="text-align:center">派许加权+调整股本</td><td style="text-align:center">规模</td><td style="text-align:center">日均总市值</td></tr></tbody></table></div><p>从指数样本股选取标准上看，市值是重点考虑的方面。</p><p>从加权方式上看股本需要加入初步的因子库。</p><p>考虑到个股的通用性质，初步加入了roe、净利润增长率（成长性因子）、PE（价值）、换手率等因子。</p><div class="table-container"><table><thead><tr><th style="text-align:center">因子名称</th><th style="text-align:center">计算方法</th><th style="text-align:center">因子描述</th></tr></thead><tbody><tr><td style="text-align:center">市值</td><td style="text-align:center">总市值=个股当日股价*当日总股本</td><td style="text-align:center">规模相关，信息包含股本和股价</td></tr><tr><td style="text-align:center">股本</td><td style="text-align:center">报表科目</td><td style="text-align:center">规模相关</td></tr><tr><td style="text-align:center">EPS</td><td style="text-align:center">当期净利润/普通股加权平均</td><td style="text-align:center">业绩相关</td></tr><tr><td style="text-align:center">ROE</td><td style="text-align:center">归属母公司的净利润占比<em>销售净利率</em>资产周转率*权益乘数</td><td style="text-align:center">盈利能力相关</td></tr><tr><td style="text-align:center">净利润增长率</td><td style="text-align:center">（本期-上年同期调整数）/ABS上年同期调整数*100%</td><td style="text-align:center">成长能力相关</td></tr><tr><td style="text-align:center">PE</td><td style="text-align:center">市值/当期净利润</td><td style="text-align:center">估值因子</td></tr><tr><td style="text-align:center">换手率</td><td style="text-align:center">成交量/总股数</td><td style="text-align:center">行情相关</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = time.clock()</span><br><span class="line">begin_date = <span class="string">&#x27;2013-01-01&#x27;</span></span><br><span class="line">end_date = <span class="string">&#x27;2018-01-02&#x27;</span></span><br><span class="line">TradeDate = get_period_date(<span class="string">&#x27;w&#x27;</span>,begin_date,end_date)</span><br><span class="line">factorData = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> TradeDate:</span><br><span class="line">    stockList = get_index_stocks(<span class="string">&#x27;00002.XSHG&#x27;</span>,date)+get_index_stocks(<span class="string">&#x27;39107.XSHE&#x27;</span>,date)</span><br><span class="line">    df_fund = get_fundamentals(query(valuation.code, valuation.turnover_ratio, valuation.pe_ratio, ……))</span><br><span class="line">    df_fund = df_fund.set_index([<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line">    factorData[date] = df_fund</span><br><span class="line">elapsed = (time.clock() - start)</span><br><span class="line">pring(<span class="string">&quot;Time used:&quot;</span>,elapsed)</span><br></pre></td></tr></table></figure><h3 id="因子暴露分析"><a href="#因子暴露分析" class="headerlink" title="因子暴露分析"></a>因子暴露分析</h3><p>为了判断上证50、沪深300和中证500在历史上各因子的暴露情况，我们以周为频率测算因子相对于全市场的偏离程度。考虑可比性和统一标尺，我们使用的数据为因子当日的排序。计算步骤如下：</p><ul><li>将每日因子按照从大到小排序；</li><li>从中取出属于某一指数的成分股，计算因子的排序平均值；</li><li>暴露度=（指数因子排序平均值-当日全市场排序中间值）/当日股票总个数。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">Fields = [<span class="string">&#x27;trunover_ratio&#x27;</span>,<span class="string">&#x27;pe_ratio&#x27;</span>,<span class="string">&#x27;market_cap&#x27;</span>,<span class="string">&#x27;capitalization&#x27;</span>,<span class="string">&#x27;eps&#x27;</span>,<span class="string">&#x27;roe&#x27;</span>,<span class="string">&#x27;inc_net_profit_year_on_year&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getExplore</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;SH50&#x27;</span>:</span><br><span class="line">        index = <span class="string">&#x27;000016.XSHG&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;HS300&#x27;</span>:</span><br><span class="line">        index = <span class="string">&#x27;000300.XSHG&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;ZZ500&#x27;</span>:</span><br><span class="line">        index = <span class="string">&#x27;000905.XSHG&#x27;</span></span><br><span class="line">    explore = pd.DataFrame(index = TradeDate)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Fields:</span><br><span class="line">        tempExplore = []</span><br><span class="line">        <span class="keyword">for</span> date <span class="keyword">in</span> TradeDate:</span><br><span class="line">            stockList = get_index_stocks(index,date)</span><br><span class="line">            temp = factorData[date][[i]]</span><br><span class="line">            temp = temp.sort([i],ascending = <span class="literal">False</span>)</span><br><span class="line">            temp[<span class="string">&#x27;rank&#x27;</span>] = <span class="built_in">range</span>(<span class="built_in">len</span>(temp)+<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">            tempExplore.append((temp.loc[stockList,<span class="string">&#x27;rank&#x27;</span>].mean() - <span class="built_in">len</span>(temp)/<span class="number">2</span>)/<span class="built_in">len</span>(temp))</span><br><span class="line">        explore[i] = tempExplore</span><br><span class="line">    <span class="keyword">return</span> explore</span><br><span class="line">result_SH50 = []</span><br><span class="line">result_HS300 = []</span><br><span class="line">result_ZZ500 = []</span><br><span class="line">explore1 = getExplore(<span class="string">&#x27;SH50&#x27;</span>)</span><br><span class="line">explore2 = getExplore(<span class="string">&#x27;HS300&#x27;</span>)</span><br><span class="line">explore3 = getExplore(<span class="string">&#x27;ZZ500&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Fields:</span><br><span class="line">    result_SH50.append(explore1[i].mean())</span><br><span class="line">    result_HS300.append(explore2[i].mean())</span><br><span class="line">    result_ZZ500.append(explore3[i].mean())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Year = [<span class="string">&#x27;2013&#x27;</span>,<span class="string">&#x27;2014&#x27;</span>,<span class="string">&#x27;2015&#x27;</span>,<span class="string">&#x27;2016&#x27;</span>,<span class="string">&#x27;2017&#x27;</span>]</span><br><span class="line">Fields = [<span class="string">&#x27;trunover_ratio&#x27;</span>,<span class="string">&#x27;pe_ratio&#x27;</span>,<span class="string">&#x27;market_cap&#x27;</span>,<span class="string">&#x27;capitalization&#x27;</span>,<span class="string">&#x27;eps&#x27;</span>,<span class="string">&#x27;roe&#x27;</span>,<span class="string">&#x27;inc_net_profit_year_on_year&#x27;</span>]</span><br><span class="line">total1 = pd.DataFrame()</span><br><span class="line">total2 = pd.DataFrame()</span><br><span class="line">total3 = pd.DataFrame()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Year)):</span><br><span class="line">    total1[Year[i]] = explore1.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total2[Year[i]] = explore2.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total3[Year[i]] = explore3.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(Year)))</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fields:</span><br><span class="line">    plt.bar(x, total1.loc[i], <span class="number">0.3</span>, label = i)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(Year)),Year)</span><br><span class="line">ax.set_title(<span class="string">&quot;SH50&quot;</span>,fontsize=<span class="number">21</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211517531.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211517751.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211518834.png" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">bar_width = <span class="number">0.3</span></span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(result_SH50)))</span><br><span class="line">plt.bar(x, result_SH50,bar_width,label=<span class="string">&#x27;SH50&#x27;</span>)</span><br><span class="line">plt.bar(x+bar_width, result_HS300,bar_width,label=<span class="string">&#x27;HS300&#x27;</span>)</span><br><span class="line">plt.bar(x+bar_width+bar_width, result_ZZ500,bar_width,label=<span class="string">&#x27;ZZ500&#x27;</span>)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(result_SH50)),Fields)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211521269.png" alt=""></p><p>横坐标为年度，颜色点代表当年的因子暴露情况。</p><ul><li><p>市值和股本因子的偏离度在每一年均是最高的。上证50市值和股本的偏离度稳定48%，沪深300的偏离度稳定在42%，而中证500的偏离度从最初的19%左右逐步提升至24%。</p></li><li><p>中等偏离度的因子包括换手率、PE、EPS、ROE 因子，这些因子在上证50的偏离度在20%-30%左右，在沪深300的偏离度在15%-25%左右，在中证500只有10%以下。</p></li><li><p>偏离度最小的是净利润增长率因子，在三大指数中，净利润增长率的偏离度几乎为0。也就是说，大市值和小市值个股在成长性方面来看，差异不大。</p></li><li><p>因子暴露度情况排序为：市值&gt;股本&gt;换手率&gt;股本&gt;PE&gt;ROE&gt;净利润增长率。因为三大股指在净利润增长率因子上的暴露度几乎为0，我们可以考虑将该因子移出风险因子库。</p></li></ul><h3 id="因子相关性分析"><a href="#因子相关性分析" class="headerlink" title="因子相关性分析"></a>因子相关性分析</h3><p>除了需要考虑因子的暴露之外，还需要计算因子之间的相关性。将相关性较高的因子区分开来，可以降低因子共线性风险并且减少因子个数。</p><h4 id="相关性平均值"><a href="#相关性平均值" class="headerlink" title="相关性平均值"></a>相关性平均值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getCorr</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;SH50&#x27;</span>:</span><br><span class="line">        index == <span class="string">&#x27;00016.XSHG&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;HS300&#x27;</span>:</span><br><span class="line">        index = <span class="string">&#x27;00300.XSHG&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;ZZ500&#x27;</span>:</span><br><span class="line">        index = <span class="string">&#x27;00905.XSHG&#x27;</span></span><br><span class="line">    corr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> date <span class="keyword">in</span> TradeDate:</span><br><span class="line">        stockList = get_index_stocks(index,date)</span><br><span class="line">        temp = factorData[date].loc[stockList,:]</span><br><span class="line">        corr[date] = temp.corr()</span><br><span class="line">    corr = pd.Panel.from_dict(corr)</span><br><span class="line">    <span class="keyword">return</span> corr</span><br><span class="line">corr_SH50 = getCorr(<span class="string">&#x27;SH50&#x27;</span>)</span><br><span class="line">corr_HS300 = getCorr(<span class="string">&#x27;HS300&#x27;</span>)</span><br><span class="line">corr_ZZ500 = getCorr(<span class="string">&#x27;ZZ500&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(corr_SH50.mean(axis = <span class="number">0</span>), annot=<span class="literal">True</span>, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;SH50&quot;</span>,rontsize=<span class="number">21</span>)</span><br><span class="line">fig.show</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(corr_HS300.mean(axis = <span class="number">0</span>), annot=<span class="literal">True</span>, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;HS300&quot;</span>,rontsize=<span class="number">21</span>)</span><br><span class="line">fig.show</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(corr_ZZ500.mean(axis = <span class="number">0</span>), annot=<span class="literal">True</span>, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;ZZ500&quot;</span>,rontsize=<span class="number">21</span>)</span><br><span class="line">fig.show</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211532097.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211532645.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211532196.png" alt=""></p><p>从上证50来看，相关性最高的因子为股本和市值；</p><p>从沪深300来看，和上证50相似，但换手率和市值的相关性降低；</p><p>从中证500来看，和其他两个指数相似，换手率和市值的相关性进一步降低。</p><h4 id="相关性标准差"><a href="#相关性标准差" class="headerlink" title="相关性标准差"></a>相关性标准差</h4><p>各因子在三大股指中的相关性标准差，标准差越小，相关性越稳定。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(corr_SH50.std(axis=<span class="number">0</span>),annot=<span class="literal">True</span>,vmax=<span class="number">1</span>,vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;SH50&quot;</span>,fontsize=<span class="number">21</span>)</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(corr_SH50.std(axis=<span class="number">0</span>),annot=<span class="literal">True</span>,vmax=<span class="number">1</span>,vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;HS300&quot;</span>,fontsize=<span class="number">21</span>)</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(corr_SH50.std(axis=<span class="number">0</span>),annot=<span class="literal">True</span>,vmax=<span class="number">1</span>,vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;ZZ500&quot;</span>,fontsize=<span class="number">21</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211559035.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211559313.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211559858.png" alt=""></p><p>从上证50来看，波动性最高的为净利润增长率和PE，其次是净利润增长率和ROE；</p><p>从沪深300来看，和上证50相似，但波动性降低；</p><p>从中证500来看，和其他两个指数相似，波动性进一步降低。</p><h4 id="相关强度"><a href="#相关强度" class="headerlink" title="相关强度"></a>相关强度</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap((corr_SH50.mean(axis=<span class="number">0</span>)/corr_SH50.std(axis=<span class="number">0</span>)).astype(<span class="built_in">int</span>),annot=<span class="literal">True</span>,vmax=<span class="number">1</span>,vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;SH50&quot;</span>,fontsize=<span class="number">21</span>)</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap((corr_HS300.mean(axis=<span class="number">0</span>)/corr_HS300.std(axis=<span class="number">0</span>)).astype(<span class="built_in">int</span>),annot=<span class="literal">True</span>,vmax=<span class="number">1</span>,vmin=<span class="number">0</span>)</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap((corr_ZZ500.mean(axis=<span class="number">0</span>)/corr_ZZ500.std(axis=<span class="number">0</span>)).astype(<span class="built_in">int</span>),annot=<span class="literal">True</span>,vmax=<span class="number">1</span>,vmin=<span class="number">0</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211603550.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211603776.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211604601.png" alt=""></p><p>整体来看，相关强度较高的组合有股本&amp;市值、ROE&amp;市值、EPS&amp;市值、净利润增长率&amp;市值、ROE&amp;EPS、净利润增长率&amp;EPS、净利润增长率和ROE。</p><p>最终因子组合中应避免两者的同时出现。</p><h3 id="因子IC分析"><a href="#因子IC分析" class="headerlink" title="因子IC分析"></a>因子IC分析</h3><p>除了考虑因子的相关性，因子的选股能力是我们第三个评判标准。</p><p>通过因子的周IC值选择解释力度较高的因子：</p><ul><li>选出股票池</li><li>因子按照从大到小排序</li><li>后一日收益率按照从大到小排序</li><li>计算两个排序之间的相关性，即RankIC</li></ul><h4 id="IC均值分析"><a href="#IC均值分析" class="headerlink" title="IC均值分析"></a>IC均值分析</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factor_IC_analysis</span>(<span class="params">factorData,index</span>):</span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;SH50&#x27;</span>:</span><br><span class="line">        index == <span class="string">&#x27;00016.XSHG&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;HS300&#x27;</span>:</span><br><span class="line">        index = <span class="string">&#x27;00300.XSHG&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="string">&#x27;ZZ500&#x27;</span>:</span><br><span class="line">        index = <span class="string">&#x27;00905.XSHG&#x27;</span></span><br><span class="line">    IC = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> date <span class="keyword">in</span> TradeDate[:-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> index:</span><br><span class="line">            stockList = get_index_stocks(index,date)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stockList = <span class="built_in">list</span>(factorData[date].index)</span><br><span class="line">        df_close = get_price(stockList,date,TradeDate[TradeDate.index(date)+<span class="number">1</span>],<span class="string">&#x27;daily&#x27;</span>,[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> df_close.empty:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        df_pchg = df_close[<span class="string">&#x27;close&#x27;</span>].iloc[-<span class="number">1</span>,:]/df_close[<span class="string">&#x27;close&#x27;</span>].iloc[<span class="number">0</span>,:]-<span class="number">1</span></span><br><span class="line">        R_T = pd.DataFrame()</span><br><span class="line">        R_T[<span class="string">&#x27;pchg&#x27;</span>] = df_pchg</span><br><span class="line">        IC_Field = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Fields:</span><br><span class="line">            factor_data = factorData[date].loc[stockList, i]</span><br><span class="line">            R_T[<span class="string">&#x27;factor&#x27;</span>] = factor_data</span><br><span class="line">            R_T = R_T.dropna()</span><br><span class="line">            IC_Field.append(st.pearsonr(R_T.pchg.rank(),R_T[<span class="string">&#x27;factor&#x27;</span>].rank())[<span class="number">0</span>])</span><br><span class="line">        IC.append(IC_Field)</span><br><span class="line">    result = pd.DataFrame(index = TradeDate[:-<span class="number">1</span>],columns = Fields, data = IC)</span><br><span class="line">    result = result.dropna(how = <span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">IC_SH50 = factor_IC_analysis(factorData, <span class="string">&#x27;SH50&#x27;</span>)</span><br><span class="line">IC_HS300 = factor_IC_analysis(factorData, <span class="string">&#x27;HS300&#x27;</span>)        </span><br><span class="line">IC_ZZ500 = factor_IC_analysis(factorData, <span class="string">&#x27;ZZ500&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = pd.DataFrame()</span><br><span class="line">temp[<span class="string">&#x27;A&#x27;</span>] = IC_A.mean()</span><br><span class="line">temp[<span class="string">&#x27;SH50&#x27;</span>] = IC_SH50.mean()</span><br><span class="line">temp[<span class="string">&#x27;HS300&#x27;</span>] = IC_HS300.mean()</span><br><span class="line">temp[<span class="string">&#x27;ZZ500&#x27;</span>] = IC_ZZ500.mean()</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(temp,annot=<span class="literal">True</span>,vmax=<span class="number">1</span>,vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;IC Mean&quot;</span>, fontsize=<span class="number">21</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211618970.png" alt=""></p><p>全市场和三大股指中各因子IC的周平均值均在$\plusmn$1%以上，说明因子的解释力度都不错。</p><p>其中，换手率的选股能力最强，其次为市值因子，而ROE因子效果在所有因子中最差。</p><p>为了进一步分析因子的选股能力，接下来进行IC的波动性分析。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Year = [<span class="string">&#x27;2013&#x27;</span>,<span class="string">&#x27;2014&#x27;</span>,<span class="string">&#x27;2015&#x27;</span>,<span class="string">&#x27;2016&#x27;</span>,<span class="string">&#x27;2017&#x27;</span>]</span><br><span class="line">Fields = [<span class="string">&#x27;trunover_ratio&#x27;</span>,<span class="string">&#x27;pe_ratio&#x27;</span>,<span class="string">&#x27;market_cap&#x27;</span>,<span class="string">&#x27;capitalization&#x27;</span>,<span class="string">&#x27;eps&#x27;</span>,<span class="string">&#x27;roe&#x27;</span>,<span class="string">&#x27;inc_net_profit_year_on_year&#x27;</span>]</span><br><span class="line">total1 = pd.DataFrame()</span><br><span class="line">total2 = pd.DataFrame()</span><br><span class="line">total3 = pd.DataFrame()</span><br><span class="line">total4 = pd.DataFrame()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Year)):</span><br><span class="line">    total1[Year[i]] = IC_A.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total2[Year[i]] = IC_SH50.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total3[Year[i]] = IC_HS300.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total3[Year[i]] = IC_ZZ500.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(Year)))</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Fields:</span><br><span class="line">    plt.bar(x, total1.loc[i], <span class="number">0.3</span>, label = i)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(Year)),Year)</span><br><span class="line">ax.set_title(<span class="string">&quot;A&quot;</span>,fontsize=<span class="number">21</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211625458.png" alt=""></p><p><img src="C:/Users/yumiaomiao/Desktop/2.png" alt=""></p><p><img src="C:/Users/yumiaomiao/Desktop/3.png" alt="3"></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211625730.png" alt="4"></p><p>各个因子在上证50中的波动性最大，HS300其次，接着是ZZ500与全市场。</p><p>换手率因子在各个指数成分股中的波动性最大，净利润增长率因子在各个指数成分股中波动性最小。</p><h4 id="IC绝对值均值分析"><a href="#IC绝对值均值分析" class="headerlink" title="IC绝对值均值分析"></a>IC绝对值均值分析</h4><p>为了考察绝对选股能力，计算各因子IC的绝对值的平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IC_A = <span class="built_in">abs</span>(IC_A)</span><br><span class="line">IC_SH50 = <span class="built_in">abs</span>(IC_SH50)</span><br><span class="line">IC_HS300 = <span class="built_in">abs</span>(IC_HS300)</span><br><span class="line">IC_ZZ500 = <span class="built_in">abs</span>(IC_ZZ500)</span><br><span class="line">temp = pd.DataFrame()</span><br><span class="line">temp[<span class="string">&#x27;A&#x27;</span>] = IC_A.mean()</span><br><span class="line">temp[<span class="string">&#x27;SH50&#x27;</span>] = IC_SH50.mean()</span><br><span class="line">temp[<span class="string">&#x27;HS300&#x27;</span>] = IC_HS300.mean()</span><br><span class="line">temp[<span class="string">&#x27;ZZ500&#x27;</span>] = IC_ZZ500.mean()</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.heatmap(temp, annot=<span class="literal">True</span>, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;IC ABS Mean&quot;</span>, fontsize=<span class="number">21</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211630716.png" alt=""></p><p>整体上可见 IC 的绝对值的平均值最高的是上证50，其次是沪深300，再次是中证500。也就是说上证50指数的因子选股能力更加明显，但波动也较大。</p><p>换手率因子和市值因子在大部分指数中绝对值平均值最大，可见其波动性最大。</p><p>净利润增长率因子的绝对值平均值最小，该因子的波动性最小。</p><p>此结论与 IC 均值年度分析结果基本一致。</p><p>接下来分年度展示了各因子 IC 的绝对值平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Year = [<span class="string">&#x27;2013&#x27;</span>,<span class="string">&#x27;2014&#x27;</span>,<span class="string">&#x27;2015&#x27;</span>,<span class="string">&#x27;2016&#x27;</span>,<span class="string">&#x27;2017&#x27;</span>]</span><br><span class="line">Fields = [<span class="string">&#x27;trunover_ratio&#x27;</span>,<span class="string">&#x27;pe_ratio&#x27;</span>,<span class="string">&#x27;market_cap&#x27;</span>,<span class="string">&#x27;capitalization&#x27;</span>,<span class="string">&#x27;eps&#x27;</span>,<span class="string">&#x27;roe&#x27;</span>,<span class="string">&#x27;inc_net_profit_year_on_year&#x27;</span>]</span><br><span class="line">total1 = pd.DataFrame()</span><br><span class="line">total2 = pd.DataFrame()</span><br><span class="line">total3 = pd.DataFrame()</span><br><span class="line">total4 = pd.DataFrame()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Year)):</span><br><span class="line">    total1[Year[i]] = IC_A.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total2[Year[i]] = IC_SH50.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total3[Year[i]] = IC_HS300.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">    total3[Year[i]] = IC_ZZ500.iloc[i*<span class="built_in">len</span>(explore1)/<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="built_in">len</span>(explore1)/<span class="number">5</span>,:].mean()</span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(Year)))</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Fields:</span><br><span class="line">    plt.bar(x, total1.loc[i], <span class="number">0.3</span>, label = i)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(Year)),Year)</span><br><span class="line">ax.set_title(<span class="string">&quot;A&quot;</span>,fontsize=<span class="number">21</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="C:/Users/yumiaomiao/Desktop/1.png" alt=""></p><p><img src="C:/Users/yumiaomiao/Desktop/2.png" alt="2"></p><p><img src="C:/Users/yumiaomiao/Desktop/3.png" alt="3"></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211633931.png" alt="4"></p><h3 id="因子组合确定"><a href="#因子组合确定" class="headerlink" title="因子组合确定"></a>因子组合确定</h3><p>因子组合的评判标准分为三点：因子暴露度、因子相关强度和因子选个股能力。</p><ul><li><p>三大股指的市值和股本因子的偏离度均是最高的。中等偏离度的因子包括：换手率、ROE、PE、EPS 因子。偏离度最小的是净利润增长率因子。</p></li><li><p>需剔除的相关强度较高的组合有：股本&amp;市值、ROE&amp;市值、EPS&amp;市值、净利润增长率&amp;市值、ROE&amp;EPS、净利润增长率&amp;EPS、净利润增长率和ROE。</p></li><li><p>换手率因子选股能力较强，净利润增长率较弱。</p></li></ul><p>综合以上结论，综合选择暴露度高、相关强度低和选股能力强的因子，即股本、换手率和EPS作为三因子组合较为合适。</p><h3 id="模型选股"><a href="#模型选股" class="headerlink" title="模型选股"></a>模型选股</h3><p>本文采用收益率预测方式进行选股，基于模型对日频因子收益率进行计算，预测股票未来收益。</p><p>收益预测模型有三种：收益移动均值模型、收益加权移动均值模型、残差模型。</p><p>根据中国银河证券研报《基于多因子框架的收益预测模型》一文，对三种收益率回测模型进行 10 层分层回测和不同预测周期回测结果可得：残差模型更适合去除风险个股；和收益移动均值模型相比，收益加权移动均值模型的分层能力更强。在收益加权移动均值模型中，λ取值 19。</p><p>因此，本文的回测阶段采用收益加权移动均值模型预测未来股票收益。</p><h3 id="回测"><a href="#回测" class="headerlink" title="回测"></a>回测</h3><p>回测时间：2018.1.1-2021.4.1，共3年零3个月。</p><p>选取因子：股本、换手率和 EPS 组合。</p><h4 id="导入函数库"><a href="#导入函数库" class="headerlink" title="导入函数库"></a>导入函数库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">from</span> six <span class="keyword">import</span> StringIO</span><br><span class="line">frome jqfactor <span class="keyword">import</span> winsorize_med</span><br><span class="line"><span class="keyword">from</span> jqfactor <span class="keyword">import</span> neutralize</span><br><span class="line"><span class="keyword">from</span> jqfactor <span class="keyword">import</span> standardlize</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br></pre></td></tr></table></figure><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>剔除ST股，剔除停牌及退市股票，剔除上市不足3个月的股票。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_stock_A</span>(<span class="params">begin_date</span>):</span><br><span class="line">    begin_date = <span class="built_in">str</span>(begin_date)</span><br><span class="line">    stockList = get_index_stocks(<span class="string">&#x27;000002.XSHG&#x27;</span>, begin_date)+get_index_stocks(<span class="string">&#x27;399107.XSHE&#x27;</span>,begin_date)</span><br><span class="line">    st_data = get_extras(<span class="string">&#x27;is_st&#x27;</span>,stockList,count=<span class="number">1</span>,end_date=begin_date)</span><br><span class="line">    stockList = [stock <span class="keyword">for</span> stock <span class="keyword">in</span> stockList <span class="keyword">if</span> <span class="keyword">not</span> st_data[stock][<span class="number">0</span>]]</span><br><span class="line">    stockList = delect_stop(stockList,begin_date)</span><br><span class="line">    <span class="keyword">return</span> stockList</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delect_stop</span>(<span class="params">stocks,beginDate,n=<span class="number">30</span>*<span class="number">3</span></span>):</span><br><span class="line">    stockList = []</span><br><span class="line">    beginDate = datetime.datetime.strptime(beginDate,<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> stock <span class="keyword">in</span> stocks:</span><br><span class="line">        start_date = get_security_info(stock).start_date</span><br><span class="line">        <span class="keyword">if</span> start_date &lt; (beginDate=datetime.timedelta(day = n)).date():</span><br><span class="line">            stockList.append(stock)</span><br><span class="line">    <span class="keyword">return</span> stockList</span><br></pre></td></tr></table></figure><h4 id="初始设定"><a href="#初始设定" class="headerlink" title="初始设定"></a>初始设定</h4><p>股票池为沪深300，持有股票总数量为100只，调仓天数为20天。</p><p>买入股票时佣金万分之三，卖出时佣金万分之三加千分之一印花税，每笔交易佣金最低扣5块钱。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    set_benchmark(<span class="string">&#x27;00300.XSHG&#x27;</span>)</span><br><span class="line">    set_option(<span class="string">&#x27;use_real_price&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line">    log.set_level(<span class="string">&#x27;order&#x27;</span>,<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    g.num = <span class="number">100</span></span><br><span class="line">    g.n = <span class="number">0</span></span><br><span class="line">    g.N = <span class="number">20</span></span><br><span class="line">    g.Day = <span class="number">20</span></span><br><span class="line">    g.alpha = <span class="number">0.05</span></span><br><span class="line">    set_order_cost(OrderCost(close_tax=<span class="number">0.001</span>, open_commission=<span class="number">0.0003</span>, close_commission=<span class="number">0.0003</span>, min_commission=<span class="number">5</span>), <span class="built_in">type</span>=<span class="string">&#x27;stock&#x27;</span>)</span><br><span class="line">    run_daily(market_open, time=<span class="string">&#x27;9:30&#x27;</span>, reference_security=<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="构建因子，买入股票"><a href="#构建因子，买入股票" class="headerlink" title="构建因子，买入股票"></a>构建因子，买入股票</h4><p>获取因子数据，对其进行去极值和标准化。</p><p>使用收益加权移动均值模型，预测未来股票收益，等权重买入排名前 100 的股票。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GetWeight</span>(<span class="params">context, N</span>):</span><br><span class="line">    date = context.previous_date</span><br><span class="line">    stockList = get_stock_A(date)</span><br><span class="line">    df_close = get_price(stockList, count=N+<span class="number">1</span>, end_date=date, frequency=<span class="string">&#x27;1d&#x27;</span>, fields=[<span class="string">&#x27;close&#x27;</span>][<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">    pchg = df_close.pct_change().shift(-<span class="number">1</span>).iloc[:-<span class="number">1</span>]</span><br><span class="line">    pchg = pchg.T</span><br><span class="line">    weight = pd.DataFrame()</span><br><span class="line">    n = <span class="built_in">len</span>(pchg.columns)</span><br><span class="line">    sunWeight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pchg.columns:</span><br><span class="line">        n -=<span class="number">1</span></span><br><span class="line">        df_fund = get_fundamentals(query(valuation.code, valuation.turnover_ratio, valuation.capitalizaton, indicator.eps).<span class="built_in">filter</span>(valuation.code.in_(stockList)).date=)</span><br><span class="line">        df_fund = df_fund.set_index([<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line">        df_fund = winsorize_med(df_fund, scale=<span class="number">1</span>, inclusive=<span class="literal">True</span>, inf2nan=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">        df_fund = standardlize(df_fund,inf2nan=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">        df_fund[<span class="string">&#x27;pchg&#x27;</span>] = pchg[i]</span><br><span class="line">        df_fund = df_fund.dropna()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> df_fund.empty:</span><br><span class="line">            x = df_fund[[<span class="string">&#x27;turnover_ratio&#x27;</span>,<span class="string">&#x27;capitalization&#x27;</span>,<span class="string">&#x27;eps&#x27;</span>]]</span><br><span class="line">            y = df_fund[<span class="string">&#x27;pchg&#x27;</span>]</span><br><span class="line">            wls = sm.OLS(y,x)</span><br><span class="line">            result = wls.fit()</span><br><span class="line">            weight[i] = result.params * np.power(<span class="number">1</span>-g.alpha, n)</span><br><span class="line">        sumWeight += np.power(<span class="number">1</span>-g.alpha, n)</span><br><span class="line">    weight = weight.<span class="built_in">sum</span>(axis = <span class="number">1</span>)/sumWeight</span><br><span class="line">    <span class="keyword">return</span> weight</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GetPredict</span>(<span class="params">context,weight</span>):</span><br><span class="line">    date = context.previous_date</span><br><span class="line">    stockList = get_stock_A(date)</span><br><span class="line">    df_fund = get_fundamentals(query(valuation.code, valuation.turnover_ratio, valuation.capitalizaton, indicator.eps).<span class="built_in">filter</span>(valuation.code.in_(stockList)).date=)</span><br><span class="line">    df_fund = df_fund.set_index([<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line">    df_fund = winsorize_med(df_fund, scale=<span class="number">1</span>, inclusive=<span class="literal">True</span>, inf2nan=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">    df_fund = standardlize(df_fund,inf2nan=<span class="literal">True</span>, axis=<span class="number">0</span>)</span><br><span class="line">    df_data = df_fund.dot(weight)</span><br><span class="line">    df_data.sort(ascending = <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> df_data</span><br></pre></td></tr></table></figure><h4 id="回测结果"><a href="#回测结果" class="headerlink" title="回测结果"></a>回测结果</h4><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303211642228.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 量化投资相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Momentum strategy </tag>
            
            <tag> Quantitative investment </tag>
            
            <tag> JoinQuant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量化择时——支持向量机模型（二）：实例</title>
      <link href="/2023/03/18/%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AE%9E%E4%BE%8B/"/>
      <url>/2023/03/18/%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文内容基于<a href="https://uqer.datayes.com/">优矿平台</a>实现，为在校课程作业，仍有较多需要改进的地方。</p><h3 id="数据选取"><a href="#数据选取" class="headerlink" title="数据选取"></a>数据选取</h3><p>选取2013.3.1-2019.4.2的沪深300指数，其中2013.3.1-2018.3.31的数据用来训练模型各参数，2018.4.1-2019.4.1的数据作为测试集，即用来回测模型的效果。</p><p>同时，为了去除数据的量纲不同带来的影响，我们对数据进行了Z-score标准化。</p><h3 id="特征指标选取"><a href="#特征指标选取" class="headerlink" title="特征指标选取"></a>特征指标选取</h3><p>在预测问题中，本文将特征指标表示为一个维数为n的向量，其选取需要遵循两个原则：</p><ul><li><p>特征指标的数量不能过少，选取的特征指标需要充分的作为解释变量。特征指标作为预测目标的重要因素，本身非常具有价值，充分的选取有利于预测准确性的提高。</p></li><li><p>特征指标的数量不能过多，关系不大或者无关的特征指标要尽可能剔除。特征指标数量过多会使得VC维过高，计算量急剧上升，解决问题的规模也会非常大，同时容易产生过拟合问题。</p></li></ul><p>基于支持向量机择时的特征指标主要有以下四类：</p><ul><li><p>时间序列数据指标。例如收盘价、成交额、买入价、持仓量等。</p></li><li><p>技术指标。技术指标在股票投资中主要用于技术分析，但在给予支持向量机择时中仅仅作为特征指标来使用。技术指标的种类繁多，在选择时要选择与股价关系密切的指标。</p></li><li><p>宏观变量指标。对于投资期限较长的预测，不少模型会加入宏观变量指标。例如利率、汇率、CPI-PPI、M1、M2、金价、进出口额、消费者信息指数，甚至包括大盘指数作为判断大势趋势等等。宏观变量指标并不单独使用，往往会选取一个或者几个与时间序列指标或技术指标结合使用。</p></li><li><p>创新指标。例如利用网络爬虫技术，自动抓取并量化投资者情绪作为特征指标。有的则基于网络舆情，抓取微博、股吧等股评观点，量化对网络舆情作为特征指标等。这些创新的特征指标也往往需要结合时间序列指标或者技术指标来使用。</p></li></ul><p>基本面数据一般会作为中长期择时的特征指标，但这里并没有将基本面作为特征指标，主要原因：一是基本面数据在支持向量机的运用主要用于择股；二是我国股市起步较晚，基本面数据与宏观数据公布的频率比较低，最短的月度数量也比较有限，数据量的有限使得对单只股票使用这些数据进行择时比较困难。</p><p>我们通过研究现有研究报告和文献，以及结合数据的可获取难易程度，选取了比较成熟、被证明有效的特征指标如下：</p><ul><li><p>X1——收盘指数</p></li><li><p>X2——当日最大指数</p></li><li><p>X3——当日最小指数</p></li><li><p>X4——涨跌幅</p></li><li><p>X5——成交量</p></li><li><p>X6——前30日平均涨跌幅</p></li><li><p>X7——前30日最大日波动</p></li></ul><h3 id="SVM模型评价指标选取"><a href="#SVM模型评价指标选取" class="headerlink" title="SVM模型评价指标选取"></a>SVM模型评价指标选取</h3><p>本文选取的策略评价指标有年化收益率、贝塔、夏普比率、收益波动率、信息比率和最大回撤率。</p><p>年化收益率与年化标准差是假设全年都按测试期内的表现而能获得的收益率和达到的标准差，通过年化的方式可以从理论上看到策略在一年内的收益与风险的表现，同时也能对于不同时长情况下的收益和风险情况进行比较。</p><p>夏普比率是单位风险的超额收益情况，它是最为经典的收益与风险进行综合度量的指标，也是绝大多数策略模型都会使用的评价指标。</p><p>最大回撤率表明的是策略在运行时内出现的最大亏损，在某种意义上可以认为最大回撤率是衡量风险的更重要指标。</p><h3 id="参数设定"><a href="#参数设定" class="headerlink" title="参数设定"></a>参数设定</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> CAL.PyCAL <span class="keyword">import</span> Date</span><br><span class="line"><span class="keyword">from</span> CAL.PyCAL <span class="keyword">import</span> Calendar</span><br><span class="line"><span class="keyword">from</span> CAL.PyCAL <span class="keyword">import</span> BizDayConvention</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line">start = <span class="string">&#x27;2019-01-01&#x27;</span>  <span class="comment">#回测起始时间</span></span><br><span class="line">end = <span class="string">&#x27;2019-04-01&#x27;</span>  <span class="comment">#回测结束时间</span></span><br><span class="line">benchmark = <span class="string">&#x27;HS300&#x27;</span>  <span class="comment">#参考标准</span></span><br><span class="line">universe = set_universe(<span class="string">&#x27;HS300&#x27;</span>)  <span class="comment">#证券池</span></span><br><span class="line">capital_base = <span class="number">100000</span>  <span class="comment">#起始资金</span></span><br><span class="line">freq = <span class="string">&#x27;d&#x27;</span>  <span class="comment">#数据频率</span></span><br><span class="line">refresh_rate = <span class="number">1</span>  <span class="comment">#调仓频率</span></span><br></pre></td></tr></table></figure><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fields = [<span class="string">&#x27;tradeDate&#x27;</span>,<span class="string">&#x27;closeIndex&#x27;</span>,<span class="string">&#x27;highestIndex&#x27;</span>,<span class="string">&#x27;lowstIndex&#x27;</span>,<span class="string">&#x27;turnoverVol&#x27;</span>,<span class="string">&#x27;CHG&#x27;</span>,<span class="string">&#x27;CHGPct&#x27;</span>]</span><br><span class="line">stock = <span class="string">&#x27;00300&#x27;</span></span><br><span class="line">index_raw = DataAPI.MktIdxdGet(ticker=stock,beginDate=<span class="string">u&quot;2013-03-01&quot;</span>,endDate=<span class="string">u&quot;2018-03-31&quot;</span>,field-fields,pandas=<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">index_date = index_raw.set_index(<span class="string">&#x27;tradeDate&#x27;</span>)</span><br><span class="line">index_date = index_date.dropna()</span><br><span class="line">index_date[<span class="string">&#x27;max_difference&#x27;</span>] = index_date[<span class="string">&#x27;highestIndex&#x27;</span>] - index_date[<span class="string">&#x27;lowestIndex&#x27;</span>]</span><br><span class="line"></span><br><span class="line">index_date[<span class="string">&#x27;max_of_30day&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">index_date[<span class="string">&#x27;min_of_30day&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">index_date[<span class="string">&#x27;max_difference_of_30day&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">index_date[<span class="string">&#x27;closeIndex_after30day&#x27;</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(index_date)-<span class="number">30</span>):</span><br><span class="line">    index_date[<span class="string">&#x27;max_of_30day&#x27;</span>][i+<span class="number">30</span>] = <span class="built_in">max</span>(index_date[<span class="string">&#x27;highestIndex&#x27;</span>][i:i+<span class="number">30</span>])</span><br><span class="line">    index_date[<span class="string">&#x27;min_of_30day&#x27;</span>][i+<span class="number">30</span>] = <span class="built_in">min</span>(index_date[<span class="string">&#x27;lowestIndex&#x27;</span>][i:i+<span class="number">30</span>])</span><br><span class="line">    index_date[<span class="string">&#x27;max_difference_of_30day&#x27;</span>][i+<span class="number">30</span>] = <span class="built_in">max</span>(index_date[<span class="string">&#x27;max_difference&#x27;</span>][i:i+<span class="number">30</span>])</span><br><span class="line">    index_date[<span class="string">&#x27;closeIndex_after30day&#x27;</span>][i] = index_date[<span class="string">&#x27;closeIndex&#x27;</span>][i:i+<span class="number">30</span>]</span><br><span class="line">    </span><br><span class="line">index_date = index_date.dropna()</span><br><span class="line">lables_raw = index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>]</span><br><span class="line">lables = index_date[<span class="string">&#x27;closeIndex_after30days&#x27;</span>] &gt; index_date[<span class="string">&#x27;closeIndex&#x27;</span>]</span><br><span class="line">lables_ud = lables.replace(&#123;<span class="literal">True</span>:<span class="string">&#x27;up&#x27;</span>,<span class="literal">False</span>:<span class="string">&#x27;down&#x27;</span>&#125;)</span><br><span class="line">features = index_date.drop([<span class="string">&#x27;closeIndex_after30days&#x27;</span>],axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="计算调参前的模型准确率"><a href="#计算调参前的模型准确率" class="headerlink" title="计算调参前的模型准确率"></a>计算调参前的模型准确率</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">scaler = preprocessing.StandardScaler().fit(features)</span><br><span class="line">features_scaler = scaler.transform(features)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = cross_validation.train_test_split(features_scaler, lables, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">clf_svm = svm.SVC()</span><br><span class="line">clf_svm.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span><span class="string">&quot;预测准确率为：%0.2f&quot;</span> % (clf_svm.score(X_test, y_test))</span><br></pre></td></tr></table></figure><p>结果显示预测准确率为：0.73。</p><h3 id="参数寻优"><a href="#参数寻优" class="headerlink" title="参数寻优"></a>参数寻优</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i_list = []</span><br><span class="line">score_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>,<span class="number">400</span>,<span class="number">1</span>):</span><br><span class="line">    i = i/<span class="number">1.</span></span><br><span class="line">    clf_svm = svm.SVC(C = i)</span><br><span class="line">    clf_svm.fit(X_train, y_train)</span><br><span class="line">    i_list.append(i)</span><br><span class="line">    score_list.append(clf_svm.score(X_test, y_test))</span><br><span class="line">    </span><br><span class="line">score_list_df = pd.DataFrame(&#123;<span class="string">&#x27;i_list&#x27;</span>:i_list,<span class="string">&#x27;score_list&#x27;</span>:score_list&#125;)</span><br><span class="line">score_list_df.plot(x=<span class="string">&#x27;i_list&#x27;</span>, y=<span class="string">&#x27;score_list&#x27;</span>, title=<span class="string">&#x27;score change with c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对C值进行调参，结果如下图，沪深300参数C最佳取值在325-365之间。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303190007771.png" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i_list = []</span><br><span class="line">score_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="number">1</span>):</span><br><span class="line">    i = i/<span class="number">100.</span></span><br><span class="line">    clf_svm = svm.SVC(C = <span class="number">350</span>, gamma = i)</span><br><span class="line">    clf_svm.fit(X_train, y_train)</span><br><span class="line">    i_list.append(i)</span><br><span class="line">    score_list.append(clf_svm.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line">score_list_df = pd.DataFrame(&#123;<span class="string">&#x27;gamma_list&#x27;</span>:i_list,<span class="string">&#x27;score_list&#x27;</span>:score_list&#125;)</span><br><span class="line">score_list_df.plot(x=<span class="string">&#x27;gamma_list&#x27;</span>, y=<span class="string">&#x27;score_list&#x27;</span>, title=<span class="string">&#x27;score change with gamma&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对g值进行调参，结果如下图，参数g最佳取值在1-1.02之间。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303190008309.png" alt=""></p><p>采用基于交叉验证的网络搜索法在参数C和g的最佳取值范围内寻找最优解，通过优矿计算出参数C的最优值为308，g的最优值为1.0，参数最优化之后的模型准确率提高到0.8。</p><h3 id="比较SVM三种函数的准确率"><a href="#比较SVM三种函数的准确率" class="headerlink" title="比较SVM三种函数的准确率"></a>比较SVM三种函数的准确率</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i_list = []</span><br><span class="line">score_list = []</span><br><span class="line"></span><br><span class="line">kernels = [<span class="string">&#x27;linear&#x27;</span>,<span class="string">&#x27;rbf&#x27;</span>,<span class="string">&#x27;sigmoid&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> kernels:</span><br><span class="line">    clf_svm = svm.SVC(C = <span class="number">350</span>, gamma = <span class="number">1</span>, kernel = i)</span><br><span class="line">    clf_svm.fit(X_train, y_train)</span><br><span class="line">    i_list.append(i)</span><br><span class="line">    score_list.append(clf_svm.score(X_test, y_test))</span><br><span class="line">score_list_df = pd.DataFrame(&#123;<span class="string">&#x27;kernels&#x27;</span>:i_list, <span class="string">&#x27;score_list&#x27;</span>:score_list&#125;)</span><br><span class="line">score_list_df.plot(x=<span class="string">&#x27;kernels&#x27;</span>, y=<span class="string">&#x27;score_list&#x27;</span>, title=<span class="string">&#x27;score change with kernels&#x27;</span>, kind=<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303190014180.png" alt=""></p><p>三种函数中，高斯径向基函数的准确率高达0.8。</p><h3 id="判断模型稳健性"><a href="#判断模型稳健性" class="headerlink" title="判断模型稳健性"></a>判断模型稳健性</h3><p>为了判断模型是否稳健，我们让训练集合处于变化中，然后观察随着训练集合的变化，准确率的波动范围图。</p><p>这里采取的是1000-2500数据每10个变化一次。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = []</span><br><span class="line">score_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange((<span class="built_in">len</span>(featrues_scaler)-<span class="number">1000</span>)/<span class="number">10</span>):</span><br><span class="line">    num_now = <span class="built_in">len</span>(features_scaler)%<span class="number">10</span> + <span class="number">10</span>*i +<span class="number">1000</span></span><br><span class="line">    X_train, X_test, y_train, y_test = cross_validation.train_test_split(featrues_scaler[:num_now], lables[:num_now], test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br><span class="line">    clf_svm = svm.SVC(C = <span class="number">300</span>, gamma = <span class="number">1</span>)</span><br><span class="line">    clf_svm.fit(X_train, y_train)</span><br><span class="line">    num_list.append(num_now)</span><br><span class="line">    score_list.append(clf_svm.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line">score_list_df = pd.DataFrame(&#123;<span class="string">&#x27;sets_num&#x27;</span>:num_list, <span class="string">&#x27;accuracy&#x27;</span>:score_list&#125;)</span><br><span class="line">score_list_df.plot(x=<span class="string">&#x27;set_num&#x27;</span>, y=<span class="string">&#x27;accuracy&#x27;</span>, title=<span class="string">&#x27;Accuracy with sets&#x27;</span>)</span><br></pre></td></tr></table></figure><p>发现最低没有低于0.73的准确率，波动较大在0.08左右，模型稳健度较好。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303190024885.png" alt=""></p><h3 id="回测"><a href="#回测" class="headerlink" title="回测"></a>回测</h3><p>首先是比对用的空白组，纯随机策略——不控制风险，只是在沪深300股票池中随机选择股票买入，当估价上涨1.20倍时卖出。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">start = <span class="string">&#x27;2019-01-01&#x27;</span></span><br><span class="line">end = <span class="string">&#x27;2019-04-01&#x27;</span></span><br><span class="line">benchmark = <span class="string">&#x27;HS300&#x27;</span></span><br><span class="line">universe = set_universe(<span class="string">&#x27;HS300&#x27;</span>)</span><br><span class="line">capital_base = <span class="number">100000</span></span><br><span class="line">freq = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">refresh_rate = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">account</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">features_list = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">account</span>):</span><br><span class="line">    random.shuffle(account.universe)</span><br><span class="line">    <span class="keyword">for</span> stock <span class="keyword">in</span> account.universe:</span><br><span class="line">        p = account.reference_price[stock]</span><br><span class="line">        cost = account.security_cost.get(stock)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cost:</span><br><span class="line">            order_pct_to(stock, <span class="number">0.10</span>)</span><br><span class="line">        <span class="keyword">elif</span> cost <span class="keyword">and</span> p &gt;= cost*<span class="number">1.20</span>:</span><br><span class="line">            order_to(stock, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303190030957.png" alt=""></p><p>接下来，运用SVM预测模型预测沪深300指数的走势，操作方法是每日收盘后判断沪深300指数未来30天的收盘价是否大于今日的收盘价。</p><p>如果预测出上涨，在当下一日的价格低于前一日收盘价时，买入满足条件的股票，总价值占虚拟账户的10%；</p><p>如果预测出下跌或没有变化，当下一日的价格涨幅到买入价的1.2倍时，清仓卖出。</p><p>每日只进行一次交易或不进行交易，整个过程由交易系统自动进行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">start = <span class="string">&#x27;2019-01-01&#x27;</span></span><br><span class="line">end = <span class="string">&#x27;2019-04-01&#x27;</span></span><br><span class="line">benchmark = <span class="string">&#x27;HS300&#x27;</span></span><br><span class="line">universe = set_universe(<span class="string">&#x27;HS300&#x27;</span>)</span><br><span class="line">capital_base = <span class="number">100000</span></span><br><span class="line">freq = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">refresh_rate = <span class="number">1</span></span><br><span class="line">stock = <span class="string">&#x27;00300&#x27;</span></span><br><span class="line">fields = [<span class="string">&#x27;tradeDate&#x27;</span>,<span class="string">&#x27;closeIndex&#x27;</span>,<span class="string">&#x27;highstIndex&#x27;</span>,<span class="string">&#x27;lowestIndex&#x27;</span>,<span class="string">&#x27;turnoverVol&#x27;</span>,<span class="string">&#x27;CHG&#x27;</span>,<span class="string">&#x27;CHGPct&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">account</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">features_list = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">account</span>):</span><br><span class="line">    last_date = account.previous_date.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    begin_date = pd.date_range(end=last_date, periods=<span class="number">60</span>)[<span class="number">0</span>]</span><br><span class="line">    begin_date = begin_date.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    to_class = DataAPI.MktIdxdGet(ticker=<span class="string">&#x27;00300&#x27;</span>,beginDate=begin_date,endDate=last_date,field=fields,pandas=<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    to_class = to_class.dropna()</span><br><span class="line">    to_class = to_class[-<span class="number">30</span>:]</span><br><span class="line">    to_class_date = to_class.set_index(<span class="string">&#x27;tradeDate&#x27;</span>)</span><br><span class="line">    to_class_date[<span class="string">&#x27;max_difference&#x27;</span>] = to_class_date[<span class="string">&#x27;highestIndex&#x27;</span>] - to_class_date[<span class="string">&#x27;lowestIndex&#x27;</span>]</span><br><span class="line">    to_class_date_max_of_30day = <span class="built_in">max</span>(to_class_date[<span class="string">&#x27;highestIndex&#x27;</span>])</span><br><span class="line">    to_class_date_min_of_30day = <span class="built_in">min</span>(to_class_date[<span class="string">&#x27;lowestIndex&#x27;</span>])</span><br><span class="line">    to_class_date_max_difference_of_30day = <span class="built_in">max</span>(to_class_date[<span class="string">&#x27;max_difference&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    features_for_predict = to_class_date[-<span class="number">1</span>:]</span><br><span class="line">    features_for_predict[<span class="string">&#x27;max_of_30day&#x27;</span>] = to_class_date_max_of_30day</span><br><span class="line">    features_for_predict[<span class="string">&#x27;min_of_30day&#x27;</span>] = to_class_date_min_of_30day</span><br><span class="line">    features_for_predict[<span class="string">&#x27;max_difference_of_30day&#x27;</span>] = to_class_date_max_difference_of_30day</span><br><span class="line">    features_fp_scaler = scaler.transform(features_for_predict)</span><br><span class="line">    predict_up = clf_svm.predict(features_fp_scaler)</span><br><span class="line">    </span><br><span class="line">    random.shuffle(account.universe) <span class="keyword">for</span> stock <span class="keyword">in</span> account.universe:</span><br><span class="line">        p = account.reference_price[stock]</span><br><span class="line">        cost = account.security_cost.get(stock)</span><br><span class="line">        <span class="keyword">if</span> predict_up <span class="keyword">and</span> <span class="keyword">not</span> cost:</span><br><span class="line">            order_pct_to(stock, <span class="number">0.10</span>)</span><br><span class="line">        <span class="keyword">elif</span> cost <span class="keyword">and</span> p &gt;= cost*<span class="number">1.20</span>:</span><br><span class="line">            order_to(stock, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303190045366.png" alt=""></p><h3 id="评估SVM模型择时策略"><a href="#评估SVM模型择时策略" class="headerlink" title="评估SVM模型择时策略"></a>评估SVM模型择时策略</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">年化收益率</th><th style="text-align:center">贝塔</th><th style="text-align:center">夏普比率</th><th style="text-align:center">收益波动率</th><th style="text-align:center">信息比率</th><th style="text-align:center">最大回撤率</th></tr></thead><tbody><tr><td style="text-align:center">随即买入</td><td style="text-align:center">299.2%</td><td style="text-align:center">1.03</td><td style="text-align:center">10.82</td><td style="text-align:center">27.3%</td><td style="text-align:center">2.28</td><td style="text-align:center">6.0%</td></tr><tr><td style="text-align:center">SVM择时</td><td style="text-align:center">310.0%</td><td style="text-align:center">1.05</td><td style="text-align:center">11.02</td><td style="text-align:center">27.8%</td><td style="text-align:center">2.65</td><td style="text-align:center">5.8%</td></tr></tbody></table></div><p>无论是从收益情况，还是从最大回撤率来看策略的抗风险能力，SVM择时模型的效果略好于随机买入的效果。</p><p>但是从收益波动率看策略的风险要略大于随机买入策略。</p>]]></content>
      
      
      <categories>
          
          <category> 量化投资相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quantitative investment </tag>
            
            <tag> Datayes! </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量化择时——支持向量机模型（一）：介绍</title>
      <link href="/2023/03/18/%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/03/18/%E9%87%8F%E5%8C%96%E6%8B%A9%E6%97%B6%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文内容基于<a href="https://uqer.datayes.com/">优矿平台</a>实现，为在校课程作业，仍有较多需要改进的地方。</p><h3 id="支持向量机模型概念"><a href="#支持向量机模型概念" class="headerlink" title="支持向量机模型概念"></a>支持向量机模型概念</h3><p>支持向量机（简称SVM）是一种基于统计学习理论的模式识别方法，它能非常成功地处理分类、判别分析等问题，并可推广到预测与综合评价领域。其核心思想可以概括为：寻找一个最优分类超平面,使得训练样本中的两类样本点尽量被无错误的分开,并且要使两类的分类间隔最大。</p><p>SVM择时就是利用SVM技术进行大盘趋势的模式识别，将大盘区分为几个明显的模式，找出其中的特征，然后利用历史数据学习的模型来预测未来的趋势。</p><h3 id="核支持向量机"><a href="#核支持向量机" class="headerlink" title="核支持向量机"></a>核支持向量机</h3><p>支持向量机SVM可分为线性支持向量机和核支持向量机，其中线性支持向量机主要针对线性分类问题。</p><p>线性分类问题中主要需要解决最大间隔分类，最大间隔分类，即在所有可能的分类界面中，寻找使分类边缘最宽的界面，是寻找最佳分类边界的核心原则。</p><p>如下图所示，红色和蓝色两条直线，称为最大边缘超平面，两条直线间距越宽，分类的效果应越好，因此线性支持向量机的目标是寻找一组直线的参数，使得分类间隔取得最大值。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303182220100.png" alt=""></p><p>但现实中绝大多数时候，数据中会包含噪音，难以用一条直线将两类样本完美地区分开来，于是引入松弛变量的概念。</p><p>对每个样本点赋予一个松弛变量的值：如果该点落在最大边缘超平面正确的一侧，则松弛变量=0；否则，松弛变量的值等于该点到最大边缘超平面的距离，如下图所示。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303182221104.png" alt=""></p><p>引入松弛变量后，目标函数在原有的基础之上加入一项样本松弛变量之和与惩罚系数C的积。其中，惩罚系数C表示模型对错误分类的容忍度。</p><p>当C取较大的数时，即使很小的松弛变量也会造成很大的损失，因此分类器对错误分类的容忍度较低，将尽可能保证分类正确，从而导致较高的训练集正确率。</p><p>反之，当C 取较小的数时，分类器对错误分类的容忍度较高，允许错误分类的存在，分类器倾向于以最大间隔分类的原则进行分类，如下图所示。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303182223728.png" alt=""></p><p>线性支持向量机能够处理线性分类问题，然而更多情况下，样本集很难被线性分类。</p><p>对于非线性分类问题，新的解决途径则是增加维度，如下图所示，任何样本集如果利用高维映射转化到无限维上都可以被线性划分。</p><p>而核函数是为了减少映射到高维空间后的计算量而设计的一个内积函数，任意一种映射方式都对应一个确定的核函数，理论上任何满足一定数学性质的核函数都可以成为核支持向量机的核函数。</p><p>在实际应用中，通常使用线性核、多项式核、Sigmoid 核和高斯核等。</p><p>多项式核、Sigmoid 核和高斯核的核函数都包含$\gamma\$值一项，$\gamma\$决定了原始数据映射到高维数据后，在高维特征空间中的分布。</p><p>$\gamma\$越大，样本在高维空间中的分布越稀疏，样本之间间隔越远，更容易被分类边界区分开来。</p><p>$\gamma\$的选取影响着模型准确度，是SVM使用中的关键问题。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303182225355.png" alt=""></p><p>在选核函数之前，我们首先要确定数据集是否线性可分。低维数据可以直接画图辨认，高维数据可以检查凸包是否相交，不相交，则线性可分。确定线性不可分之后，需要采用核支持向量机模型。</p><p>不同核函数的分类性能和分类边界不尽相同，线性核的分类边界为直线，多项式核、Sigmoid 核和高斯核的分类边界在高维空间中为超平面，在原始空间中为曲线。线性核、低阶多项式核和Sigmoid 核计算速度快，不容易过拟合，但是在复杂分类问题下表现不佳。高阶多项式核和高斯核的优点是能够求解复杂的边界，对训练样本的分类能力强大，缺点是计算速度缓慢，并且可能导致过拟合。实际使用中需要根据数据自身的特点，选择最合适的核函数。</p><p>惩罚系数C和$\gamma\$是影响支持向量分类器性能的关键参数。实际应用中，当数据量较小的候，可以采用“网格搜索”对C和$\gamma\$进行遍历，选择全局最优参数。但是“网格搜索”计算量很大，一般难以进行，因此主要还是根据C和$\gamma\$的影响进行判断。</p><p>C和$\gamma\$越大，惩罚越多，分类器对于错误的容忍程度低；同时经过映射后的样本在高维空间的分布越稀疏，更容易被区分。这都会导致训练集的正确率更高，但是也可能带来过拟合问题，使得偏差减小但方差增大。</p><h3 id="模型基本思路"><a href="#模型基本思路" class="headerlink" title="模型基本思路"></a>模型基本思路</h3><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303182227127.jpg" alt=""></p><h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p>收集可能用到的历史数据资料，并对数据进行简单的处理。</p><p>人们将量化投资称为”黑箱“就是因为数据由输入转变为输出的过程不为他人所理解，而高质量的数据是好的输出结果的前提。此外，常被忽视的是模型的很多细节也取决于原有的数据特征，因为对数据的处理方式和数据的用处很多时候取决于数据的属性。</p><p>如果数据的获取这一环节出现了问题，策略的运行将无从谈起。获取数据的来源主要有三种：未加工的数据、二手数据和第三方供应商提供的数据。</p><h4 id="数据拆分"><a href="#数据拆分" class="headerlink" title="数据拆分"></a>数据拆分</h4><p>获取数据后第一步应该做的是数据的拆分，从而使用不同的数据对模型进行训练和测试。</p><p>这一步几乎所有国内相关文献都没有给予足够的重视，他们往往先进行数据的预处理再进行数据的拆分，这样做的后果很可能是最后的测试结果较好但真正用于实践结果时却不如意，因为这存在着”偷窥“数据的操作。</p><p>因此在数据获取后应立即进行拆分为训练集和测试集，并将测试集数据保存好，在整个模型的训练阶段都不要触碰。</p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>数据预处理最主要的工作是使不同特征指标的量纲达到一样。</p><p>最为常见的做法有两种，一种是数据的归一化，压缩数据使得对于每个自变量而言，它们的值都在同一个范围；另一种是标准化，通过压缩数据，使每个自变量值的方差和均值都一样。本文采用数据的标准化。</p><h4 id="选取特征指标与预测变量"><a href="#选取特征指标与预测变量" class="headerlink" title="选取特征指标与预测变量"></a>选取特征指标与预测变量</h4><p>特征指标的选取就是确定影响模型需要预测目标的影响因素，也就是确定输入变量。</p><p>预测变量的选取就是确定模型需要预测什么。</p><h4 id="参数寻优"><a href="#参数寻优" class="headerlink" title="参数寻优"></a>参数寻优</h4><p>参数的选择对最后支持向量机模型的好坏起着重要的作用，本文使用SVM分类器来判断涨跌，结合SVM算法寻找出适合训练集的最优参数。</p><h4 id="SVM模型训练"><a href="#SVM模型训练" class="headerlink" title="SVM模型训练"></a>SVM模型训练</h4><p>确定好整个量化择时策略模型所需要的各个参数后，就是对模型进行训练了。</p><h4 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h4><p>经过输入最优参数后的SVM算法训练后得到模型。</p><h4 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h4><p>在建立好模型后会得到基于训练集模型的评价指标，这些评价指标的值若是达到了预期的目标，就可以进入下一步，若是没有，则需要对以上各步骤进行改进，以达到满意的结果。</p><h4 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h4><p>对训练得出的模型推广（或称泛化）能力用测试集进行验证。</p><p>如果通过测试集验证后各项评价指标比较好，则策略模型表现较好，否则说明推广能力差，模型不成功。</p>]]></content>
      
      
      <categories>
          
          <category> 量化投资相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quantitative investment </tag>
            
            <tag> Datayes! </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo搭建个人网站（一）:网站搭建</title>
      <link href="/2023/03/17/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/03/17/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为基于Github+Hexo的个人网站搭建教程。</p><p>系统环境：win10</p><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><ul><li><p>进入<a href="https://github.com">https://github.com</a> 点击右上角<strong><em>sign up</em></strong></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172212687.png" alt=""></p></li></ul><h3 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h3><ul><li><p>登录github后，点击右上角<strong>+</strong>号，选择<strong>New repository</strong>创建一个与自己的博客相关的repository项目。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172212366.png" alt=""></p></li><li><p>Repository name的格式为<strong>username.github.io</strong>，例如我的username是miaomiao0426，则我的Repository name应为miaomiao0426.github.io</p></li><li><p>勾选<strong>public</strong>，勾选<strong>Add a README file</strong></p></li><li><p>拉到页面下方，点击<strong>Create repository</strong></p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172213710.png" style="zoom:80%;" /></p></li></ul><h3 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a>安装Node.js和Git</h3><ul><li><p>进入<a href="https://nodejs.org/en/download">Node.js官网</a>，按需下载相应版本安装。</p></li><li><p>进入<a href="https://git-scm.com/download/win">Git官网</a>，按需下载相应版本安装。</p></li></ul><h3 id="检验是否安装完成"><a href="#检验是否安装完成" class="headerlink" title="检验是否安装完成"></a>检验是否安装完成</h3><ul><li><p>同时按下<strong>Win键和R键</strong>，打开运行窗口，输入<strong>cmd</strong>。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172214156.png" alt=""></p></li><li><p>输入以下命令，若显示相应版本信息则安装成功。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure></li></ul><h3 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h3><p>该操作的目的是：通过git操作实现本地代码库与Github代码库的同步。</p><ul><li><p>从电脑开始页面中找到<strong>git bash</strong>并打开，之后所有的命令均在git bash中输入。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172214070.png" alt=""></p></li><li><p>输入以下命令，检查自己电脑上是否有SSH Key，如果显示No such file or directory，说明没有。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p>输入以下命令，其中邮件地址输入注册Github的邮箱地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;邮件地址@youemail.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>系统会显示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/your_user_directory/.ssh/id_rsa):</span><br></pre></td></tr></table></figure></li><li><p>点击回车。</p></li><li><p>系统会两次要求输入密码，均直接回车就好。如果想要设置密码，直接输入，但输入密码的时候是没有输入痕迹的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure></li><li><p>接下来系统会显示设置成功，并告诉你密钥存储的位置是<strong>c/Users/you/.ssh/id_rsa.pub</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/you/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/you/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置SSH密钥到github上"><a href="#配置SSH密钥到github上" class="headerlink" title="配置SSH密钥到github上"></a>配置SSH密钥到github上</h3><ul><li><p>找到密钥存储的位置，即id_rsa.pub文件。如果找不到这个文件，在.ssh文件夹中，点击查看，勾选隐藏的项目。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172215270.png" alt=""></p></li><li><p>用记事本或Notepad++打开此文件，复制其中的内容。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172215287.png" alt=""></p></li><li><p>回到github主页，点击右上角头像，点击<strong>Settings</strong>。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172216323.png" style="zoom:80%;" /></p></li><li><p>点击左侧<strong>SSH and GPG keys</strong>，点击右上方<strong>New SSH key</strong>。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172217316.png" alt=""></p></li><li><p>将刚才复制的内容粘贴进<strong>key</strong>中，<strong>Title</strong>处随便起一个名字，点击<strong>Add SSH key</strong>。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172218800.png" alt=""></p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>打开<strong>git bash</strong>，输入以下命令，内容不要改动。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li><p>系统会显示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (<span class="built_in">yes</span>/no)</span><br></pre></td></tr></table></figure></li><li><p>输入<strong>yes</strong>，<strong>回车</strong>，系统会提示输入刚才设置的密码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">&#x27;/c/Users/your_user_directory/.ssh/id_rsa&#x27;</span>:</span><br></pre></td></tr></table></figure></li><li><p>回车后，看到系统提示成功，表示git可以通过SSH链接到github了。</p></li></ul><h3 id="设置git个人信息"><a href="#设置git个人信息" class="headerlink" title="设置git个人信息"></a>设置git个人信息</h3><ul><li><p>在git bash中输入以下命令。以我个人为例，输入注册时的username即miaomiao0426，输入github注册邮箱即codewithmiaomiao@163.com。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;miaomiao0426&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;codewithmiaomiao@163.com&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ul><li><p>在本地新建一个博客文件夹，以我个人为例，在D盘新建”myblog”文件夹。</p></li><li><p>在该文件夹上，点击鼠标右键，选择<strong>Git bash here</strong>。</p></li><li><p>此时，打开的git bash窗口如下所示：</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172218011.png" alt=""></p></li><li><p>输入以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo -deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>此时，打开myblog文件夹可以发现，Hexo已经在该文件夹下面建立博客所需要的所有文件了。</p></li><li><p>输入以下命令，根据提示在浏览器输入<strong>localhost:4000</strong>预览hexo博客：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li><p>按<strong>ctrl+C</strong>可以退出预览。此时，博客给了一个默认的主题landscape，还有一篇Hello World示例文章。</p></li><li><p>我们可以修改配置自己喜欢的主题和个性化装饰（下一篇文章细讲）。</p></li></ul><h3 id="将博客部署到github"><a href="#将博客部署到github" class="headerlink" title="将博客部署到github"></a>将博客部署到github</h3><ul><li><p>进入github个人主页的<strong>repository</strong>中，复制<strong>SSH</strong>。</p><p><img src="https://cdn.staticaly.com/gh/miaomiao0426/image@main/img/202303172218933.png" alt=""></p></li><li><p>用记事本或Notepad++打开<strong>D:/myblog/_config.yml</strong>，拉到页面最下方，找到<strong>deploy处</strong>，修改代码如下，并将刚才复制的SSH码粘贴到<strong>repository:</strong> 后面（冒号后有空格）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:usename/usename.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li><li><p>修改后保存_config.yml文件，在myblog文件夹上右键打开Git bash here，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li></ul><h3 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h3><ul><li>此时在浏览器输入<strong>usename.github.io</strong>，可进入个人网站。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人网站相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
            <tag> personal website </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
